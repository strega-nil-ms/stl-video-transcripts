WEBVTT

00:00:09.739 --> 00:00:13.709
Hi and welcome back to another
VC libraries Open code review.

00:00:13.709 --> 00:00:17.488
Today we'll be looking at PR
3322 by our contributor Tyler

00:00:17.488 --> 00:00:21.139
Brawl and this is implementing
another part of the paper

00:00:21.139 --> 00:00:25.366
HE2321R2 adding another views to
the view to the ranges libraries

00:00:25.366 --> 00:00:29.208
to views zip transform. So
previously Tyler contributed the

00:00:29.208 --> 00:00:32.731
zip view and now we've got zip
transform. We just does

00:00:32.731 --> 00:00:34.909
something a little bit
different.

00:00:36.069 --> 00:00:40.613
He's got a very nice PR message
here that's explaining all the

00:00:40.613 --> 00:00:45.085
stuff that's being implemented.
So we've got the our tracking

00:00:45.085 --> 00:00:45.879
issue 2252.

00:00:47.199 --> 00:00:51.119
That lists the overall paper. I
can open that up and associate

00:00:51.119 --> 00:00:55.039
LKG issues because this is only
implementing, as I recall, one

00:00:55.039 --> 00:00:58.649
out of four views we've got zip
view, zip, transform view

00:00:58.649 --> 00:01:02.694
adjacent and adjacent transform.
So this is basically Part 2 out

00:01:02.694 --> 00:01:06.676
of four, so we won't be seeing
the feature test macker here. We

00:01:06.676 --> 00:01:10.223
only define those when the
feature is fully implemented.

00:01:10.223 --> 00:01:14.082
But there are some LWG issues
which are bug fixes against the

00:01:14.082 --> 00:01:15.949
standard that are relevant so.

00:01:16.299 --> 00:01:21.327
Let me open up, please. OK, so
we've got the paper as a whole.

00:01:21.327 --> 00:01:26.355
We've got two LWG issues. Tyler
also notes that there is usage

00:01:26.355 --> 00:01:31.303
of decay Copy language feature
that's in C + 23. The compiler

00:01:31.303 --> 00:01:33.059
doesn't have that. So.

00:01:33.129 --> 00:01:37.299
So Tyler is implementing this
essentially manually, which is a

00:01:37.299 --> 00:01:41.535
reasonable workaround. So let's
take a look at these LWG issues

00:01:41.535 --> 00:01:45.573
as a quick refresher. This is
getting rid of some comparison

00:01:45.573 --> 00:01:47.559
operators because they can be.

00:01:47.639 --> 00:01:51.069
Umm generated for us I believe.

00:01:53.139 --> 00:01:54.429
Let's see.

00:01:55.379 --> 00:01:59.883
OK. Yeah, yeah, we we only need
to provide equal and spaceship.

00:01:59.883 --> 00:02:02.839
So this is simplifying and then
this one.

00:02:03.799 --> 00:02:06.703
Is changing one of the
requirements from copy

00:02:06.703 --> 00:02:09.039
constructible to move
constructible?

00:02:09.539 --> 00:02:12.069
Umm, it looks like there were
simply on.

00:02:13.009 --> 00:02:16.758
A missed edit from a previous
patch paper, so hopefully this

00:02:16.758 --> 00:02:20.446
wording has been integrated to
the leaves working paper. We

00:02:20.446 --> 00:02:24.072
just got a new working paper
4928. This is now linked from

00:02:24.072 --> 00:02:27.821
our repos readme thanks to a new
contributor who updated our

00:02:27.821 --> 00:02:31.755
README so I can go over to rain
zip transform iterator and look

00:02:31.755 --> 00:02:32.739
for the wording.

00:02:35.829 --> 00:02:39.639
If the if this working paper
4928 UM has been updated, then

00:02:39.639 --> 00:02:43.640
we only need to look at it. We
don't need to look at all these

00:02:43.640 --> 00:02:47.641
LWG issues as well. Hopefully
this is the correct spelling. If

00:02:47.641 --> 00:02:50.499
not, I'll open up the bookmark.
There we go.

00:02:52.039 --> 00:02:56.621
OK, so sorry for jumping around.
In the synopsis, we should be

00:02:56.621 --> 00:02:58.949
seeing only equal and spaceship.

00:02:59.759 --> 00:03:04.263
For the zip transform view
iterator. So this is zip

00:03:04.263 --> 00:03:07.469
transform view iterator Scroll
down.

00:03:08.849 --> 00:03:12.840
Equal and spaceship OK, so we're
only seeing that. That's great.

00:03:12.840 --> 00:03:16.402
This issues integrated and the
other one is in a range of

00:03:16.402 --> 00:03:17.569
transform overview.

00:03:18.729 --> 00:03:19.989
Which is.

00:03:20.859 --> 00:03:23.369
Below now this is the iterator.

00:03:25.529 --> 00:03:30.441
Scroll up Yep, ranges of
transform overview and bullet

00:03:30.441 --> 00:03:33.299
.211 says if move constructible.

00:03:33.999 --> 00:03:36.658
Two on one if move
constructible. OK, so both of

00:03:36.658 --> 00:03:39.589
these issues has have been
integrated into the latest

00:03:39.589 --> 00:03:42.792
working paper, which is great.
We only need to look at the

00:03:42.792 --> 00:03:45.994
final fused version. This is the
original proposal. So zip

00:03:45.994 --> 00:03:46.809
transform view.

00:03:47.829 --> 00:03:49.099
Is.

00:03:50.049 --> 00:03:53.991
Uh oh, this is a sorry. This is
a patch paper. OK, so this is

00:03:53.991 --> 00:03:55.899
also definitely been fused in.

00:03:57.329 --> 00:04:00.203
This makes the zip transform
view constrained on move

00:04:00.203 --> 00:04:00.949
constructible.

00:04:01.919 --> 00:04:04.249
As of transform view.

00:04:05.579 --> 00:04:08.387
This is, yeah. Is it transform
view is constrained to move

00:04:08.387 --> 00:04:11.290
constructible. So this catch
paper has also been integrated.

00:04:11.290 --> 00:04:14.050
Great. So we don't need to go
look at 5 different layered

00:04:14.050 --> 00:04:16.859
things or whatever. We only need
to look at the latest WP.

00:04:18.369 --> 00:04:22.407
OK. And then other contributors,
Frederick SA, Tim Song, CPP have

00:04:22.407 --> 00:04:26.018
been reviewing this greatly
appreciated the PR has already

00:04:26.018 --> 00:04:29.690
been revised. So I will now
start looking at this. So let's

00:04:29.690 --> 00:04:31.159
go over to files change.

00:04:31.759 --> 00:04:32.389
Umm.

00:04:33.239 --> 00:04:37.724
So I think forger lines of
product code and 800 lines of

00:04:37.724 --> 00:04:41.029
tests are there about. Let me
split this.

00:04:42.119 --> 00:04:44.069
Side by side view OK.

00:04:45.779 --> 00:04:49.629
OK zip transform view, where is
the synopsis.

00:04:53.059 --> 00:04:54.529
Ranges library.

00:04:56.029 --> 00:04:59.318
Sometime I'm gonna faster
quickly scanning through this.

00:04:59.318 --> 00:05:02.319
I'm like, whoa, ranges. I
haven't seen these points

00:05:02.319 --> 00:05:05.839
before. These are adapters. Zip,
transform, view as a lot of

00:05:05.839 --> 00:05:06.359
adapters.

00:05:08.339 --> 00:05:11.027
OK, so this is the actual
section. Oh, but I wanted the

00:05:11.027 --> 00:05:11.459
overview.

00:05:12.469 --> 00:05:13.889
Here we go synopsis.

00:05:15.719 --> 00:05:18.543
Let's see. It's a little bit
annoying that things are sort of

00:05:18.543 --> 00:05:21.413
split, but this is just how the
standard specify stuff. OK, so

00:05:21.413 --> 00:05:24.282
here we go. On the other thing,
of course, we want to look out

00:05:24.282 --> 00:05:26.742
for is modules. We want to make
sure all the standard

00:05:26.742 --> 00:05:29.476
identifiers are exported. I
believe this should just be the

00:05:29.476 --> 00:05:32.254
classic transform view and the
actual views of transform. So

00:05:32.254 --> 00:05:35.215
I'll look out for that. Maybe I
can actually scan for it now. So

00:05:35.215 --> 00:05:35.899
I don't forget.

00:05:36.559 --> 00:05:38.999
Umm, this is grinding
friendship.

00:05:40.119 --> 00:05:43.215
Zip transform view itself is
exported perfect. The great

00:05:43.215 --> 00:05:46.474
thing is that that applies to
all the Member functions. All

00:05:46.474 --> 00:05:49.896
the nested classes, so we don't
care about any of them for the

00:05:49.896 --> 00:05:53.264
purposes of modules don't need
to, can't in fact can't export

00:05:53.264 --> 00:05:56.632
deduction guys, they're just
automatically attached, and then

00:05:56.632 --> 00:05:59.674
the actual zip transform is
exported. OK, so modules is

00:05:59.674 --> 00:06:00.109
perfect.

00:06:01.199 --> 00:06:02.549
OK.

00:06:03.229 --> 00:06:06.278
Nothing else is going on up
here, so we can go directly to

00:06:06.278 --> 00:06:08.139
the specification of zip
transform.

00:06:09.249 --> 00:06:13.419
That was in adapters zip.

00:06:14.899 --> 00:06:18.225
OK, welcome back to this. OK, so
let's look at the easy files

00:06:18.225 --> 00:06:21.284
first. Uh, why versus core has a
comment on what's being

00:06:21.284 --> 00:06:24.450
implemented. Use zip transform
is being implemented, so we

00:06:24.450 --> 00:06:27.723
dropped that and we just say
missing views of JSON and views

00:06:27.723 --> 00:06:31.157
JSON transform without a comma.
Perfect, no feature, just macro

00:06:31.157 --> 00:06:33.089
update at this time as I
mentioned.

00:06:34.919 --> 00:06:38.803
A new test is being added so
Tyler is updating test dot list.

00:06:38.803 --> 00:06:42.813
This is great. This makes sure
that it will be picked up by the

00:06:42.813 --> 00:06:46.134
new test harness. It is in
sorted order. Clearly the

00:06:46.134 --> 00:06:49.580
spelling is correct. That's
perfect. We've got list of

00:06:49.580 --> 00:06:53.089
compiler options. This looks
like the previous zip one.

00:06:53.709 --> 00:06:58.119
I this does require strictness.
I think this came up with.

00:06:59.259 --> 00:07:04.427
The Zip view review that it is
incompatible with permissive

00:07:04.427 --> 00:07:10.112
minus. I think I will do a quick
refresher and see if we can find

00:07:10.112 --> 00:07:11.749
that just so we're.

00:07:12.529 --> 00:07:15.719
Remembering what it is, it's not
open anymore.

00:07:16.479 --> 00:07:19.403
I think Tyler might have liked
this from the PR button. I'll

00:07:19.403 --> 00:07:21.609
just search for it from scratch.
OK this one.

00:07:22.979 --> 00:07:25.717
Is October. October is like a
lifetime ago. I can't possibly

00:07:25.717 --> 00:07:27.019
remember anything that helps.

00:07:28.979 --> 00:07:31.759
OK, I'm gonna scroll through.

00:07:32.569 --> 00:07:35.332
I guess it would have. It would
have come up in for that list,

00:07:35.332 --> 00:07:35.639
but UM.

00:07:39.339 --> 00:07:42.573
OK, we didn't have any actual
comments there. Did anybody say

00:07:42.573 --> 00:07:42.939
strict?

00:07:43.579 --> 00:07:46.119
Nope, nobody said strict. Maybe
this didn't come up.

00:07:49.369 --> 00:07:51.039
OK, it wasn't actually called
out here.

00:07:52.649 --> 00:07:57.279
But I seem to recall that it
also had strictness.

00:07:58.369 --> 00:07:59.649
It did require struct.

00:08:00.579 --> 00:08:01.109
OK.

00:08:04.059 --> 00:08:07.473
Ah, this comment explains it.
That that's that's why I was

00:08:07.473 --> 00:08:11.003
remembering. It says zip. You
iterator defines ADL overloads

00:08:11.003 --> 00:08:14.591
argument dependent lookup for
ITER swap and it remove. That's

00:08:14.591 --> 00:08:18.121
why it requires strict mode.
It's not unique to zip. You all

00:08:18.121 --> 00:08:21.593
view types whose iterators
defined overloads. OK so is that

00:08:21.593 --> 00:08:25.123
true for zip transform view
we've got the standard specified

00:08:25.123 --> 00:08:28.710
zip transform view where is its
iterator. Here's iterator. If

00:08:28.710 --> 00:08:32.414
there's ADL overloads for ITER,
swap and move, then that causes

00:08:32.414 --> 00:08:33.109
the problem.

00:08:35.179 --> 00:08:37.329
I'm not seeing it yet.

00:08:38.249 --> 00:08:40.159
Is that out?

00:08:42.649 --> 00:08:45.106
This is the class, so you
wouldn't get ADL overloads here.

00:08:45.106 --> 00:08:46.439
You would get them at top level.

00:08:47.209 --> 00:08:47.969
That's interesting.

00:08:49.619 --> 00:08:51.719
Sorry for scrolling, I know it's
hard to keep up on the video.

00:08:51.889 --> 00:08:55.489
Ah, am I missing anything here?
This is the iterator.

00:08:57.619 --> 00:08:59.529
This is the end of the class
definition.

00:09:01.859 --> 00:09:04.816
I don't see it or swapping move.
Here's a Sentinel for zip

00:09:04.816 --> 00:09:05.569
transform view.

00:09:07.539 --> 00:09:10.607
Some operator minuses equals.
OK, that's interesting. What

00:09:10.607 --> 00:09:12.999
does zip view look like? Do they
differ here?

00:09:14.869 --> 00:09:15.709
Uh.

00:09:15.309 --> 00:09:17.379
This one doesn't define its own
iterator type.

00:09:19.649 --> 00:09:22.209
I was, if you does not ohh
because it.

00:09:21.099 --> 00:09:23.169
That I catch that no zip
transform vehicle.

00:09:23.829 --> 00:09:26.567
I know it does, it does. I I was
just. I was just scrolling

00:09:25.679 --> 00:09:25.949
Ohh.

00:09:26.567 --> 00:09:27.069
through it.

00:09:28.029 --> 00:09:30.412
But I didn't see an inter swap
and move for it, so here's the

00:09:30.412 --> 00:09:30.989
transform view.

00:09:30.479 --> 00:09:32.810
It makes sense that there
wouldn't be in it or swapping

00:09:32.810 --> 00:09:33.019
move.

00:09:33.779 --> 00:09:37.100
Much like for about their
regular transform view, because

00:09:34.279 --> 00:09:34.679
OK.

00:09:36.409 --> 00:09:37.949
Uh, because you're transforming.

00:09:37.100 --> 00:09:40.078
the the the result of
dereferencing the iterator is

00:09:40.078 --> 00:09:41.739
result of calling a function.

00:09:42.559 --> 00:09:45.538
So it remove and ITER swap
wouldn't make any sense, right?

00:09:43.089 --> 00:09:43.869
Right, you're.

00:09:45.538 --> 00:09:48.669
There's nothing to move or swap.
There are ephemeral results.

00:09:47.639 --> 00:09:50.475
Yeah, you're. Yeah. You're
making. Yeah. Phantom. Yeah.

00:09:50.475 --> 00:09:51.489
Phil is a good word.

00:09:52.989 --> 00:09:56.239
OK. So that's interesting this
so that indicates that maybe

00:09:56.239 --> 00:09:59.110
this does not need to be
stripped. So the question I

00:09:59.110 --> 00:10:02.577
always have when I see something
like this where this came up a

00:10:02.577 --> 00:10:03.119
while ago.

00:10:03.199 --> 00:10:07.003
So where we were using the
strict matrix, meaning requiring

00:10:07.003 --> 00:10:10.870
permissive minus on everything a
bit more than we absolutely

00:10:10.870 --> 00:10:14.421
needed to, and we grudgingly
permit CPP latest with the

00:10:14.421 --> 00:10:18.098
permissive mode. So our new
convention is to use just the

00:10:18.098 --> 00:10:22.092
concepts latest matrix whenever
we can and only add the strict

00:10:22.092 --> 00:10:25.135
part if it's absolutely
necessary. So it wasn't

00:10:25.135 --> 00:10:28.939
necessary for zip view as Casey
mentioned. And I eventually

00:10:26.409 --> 00:10:26.669
Yeah.

00:10:28.939 --> 00:10:32.870
deduced there is an asymmetry
here. It should probably not be

00:10:32.870 --> 00:10:34.329
necessary for zip view.

00:10:34.479 --> 00:10:36.509
And if it is, we'd like to
understand why.

00:10:37.029 --> 00:10:41.589
Umm so I will link.

00:10:40.049 --> 00:10:42.499
You can probably click on that
resolve comment of mine.

00:10:43.179 --> 00:10:46.069
Which is asking does this really
needs the strict matrix?

00:10:43.639 --> 00:10:43.979
Ohh.

00:10:47.079 --> 00:10:51.067
Oh, here. Oh, here we go. OK.
There's there's Nicole asking

00:10:47.239 --> 00:10:49.699
Ohh no it isn't. I can't believe
it and so it down.

00:10:51.067 --> 00:10:55.055
and then talk about this. You
did comment, you talked about

00:10:55.055 --> 00:10:57.049
author, strict Meow crackdown.

00:10:59.529 --> 00:11:01.489
And.

00:11:03.119 --> 00:11:04.299
See.

00:11:05.449 --> 00:11:07.709
Yeah, it is specifically it
removing your swap.

00:11:10.379 --> 00:11:13.869
Yeah. So I I think I think it
should not necessarily be.

00:11:14.949 --> 00:11:15.809
Required here.

00:11:18.509 --> 00:11:21.960
Yeah. So I want what I want to
do is I want to link this thing

00:11:21.960 --> 00:11:25.412
while it's. I'll just look for
views zip. So let me go back to

00:11:25.412 --> 00:11:28.645
the room, the repo because I
don't know how to get to this

00:11:28.645 --> 00:11:29.029
faster.

00:11:30.489 --> 00:11:34.609
Got a code test test.

00:11:35.989 --> 00:11:38.139
Like for views zip.

00:11:39.219 --> 00:11:40.069
There we go.

00:11:40.819 --> 00:11:42.439
And list.

00:11:43.139 --> 00:11:44.569
Get Y for permalink.

00:11:45.919 --> 00:11:48.999
Copy or shift select this OK.

00:11:50.299 --> 00:11:52.829
OK, so close this first comment.

00:11:55.209 --> 00:12:02.689
Is the strict matrix required
for.

00:12:03.539 --> 00:12:04.159
Zip.

00:12:05.109 --> 00:12:06.159
Transform.

00:12:09.559 --> 00:12:11.539
Zip needed it.

00:12:13.399 --> 00:12:15.579
As explained by.

00:12:18.989 --> 00:12:21.741
This comment I'll say this
comment, even though your

00:12:21.741 --> 00:12:23.819
comment would also be
applicable. Blah.

00:12:25.139 --> 00:12:29.229
However, there is an
intentional.

00:12:29.939 --> 00:12:37.279
Semetary between I'm zip and
zip.

00:12:37.999 --> 00:12:39.459
Transform.

00:12:42.199 --> 00:12:44.449
And that uh, no.

00:12:45.699 --> 00:12:52.509
Zip transforms Iterator doesn't
have ADL overloads of.

00:12:53.229 --> 00:12:54.669
Enter move.

00:12:55.959 --> 00:13:05.124
And it or swap now credit Casey
as Casey Carter explained, zip

00:13:05.124 --> 00:13:07.889
transform produces.

00:13:09.149 --> 00:13:10.619
He femoral.

00:13:11.259 --> 00:13:14.909
Results due to the
transformation.

00:13:15.569 --> 00:13:16.089
Umm.

00:13:19.029 --> 00:13:20.129
I'll just leave it at that.

00:13:23.539 --> 00:13:24.279
Therefore.

00:13:24.579 --> 00:13:32.312
Uh, and saying therefore, can we
remove the strict requirement

00:13:32.312 --> 00:13:38.819
and have the tests still pass?
Or is something else?

00:13:39.839 --> 00:13:43.118
Blocking it. OK, phrase it as a
question. Let's make sure this

00:13:43.118 --> 00:13:46.085
is all not typoed. Is the strict
matrix required for zip

00:13:46.085 --> 00:13:48.949
transform? Zip needed it as
explained by this comment.

00:13:49.949 --> 00:13:54.310
Explain ADL overloads. Strict
leads matrix. However this is

00:13:54.310 --> 00:13:54.529
on.

00:13:55.349 --> 00:13:58.686
However, this is unintentional.
Asymmetry between zip and zip

00:13:58.686 --> 00:14:01.486
transform zip transforms
iterator doesn't have a DL

00:14:01.486 --> 00:14:04.770
overloads of ITER move and ITER
swap, as Casey explained zip

00:14:04.770 --> 00:14:05.309
transform.

00:14:06.629 --> 00:14:10.095
Wow, that CSS is getting really
messed up as case explained zip

00:14:10.095 --> 00:14:12.696
transform produces ephemeral
results due to the

00:14:12.696 --> 00:14:16.108
transformation. Can we remove
the strict requirement? Have the

00:14:16.108 --> 00:14:19.359
test pass or something else
blocking that? OK start review.

00:14:21.259 --> 00:14:24.425
And then to avoid overloading
the compiler, the test is split

00:14:24.425 --> 00:14:27.488
up into a bunch of different
parts. This is copied from the

00:14:27.488 --> 00:14:30.757
other tests, and I assume it's
still necessary here, so I'm not

00:14:30.757 --> 00:14:34.025
gonna question that defined to
Simply put forward bidirectional

00:14:34.025 --> 00:14:37.089
and random. OK, I'll keep a
lookout when we actually review

00:14:37.089 --> 00:14:40.204
that and I forgot to check, we
do have our copyright license

00:14:40.204 --> 00:14:43.370
banner here. Perfect. Same for
the test. I'll quickly look at

00:14:43.370 --> 00:14:46.383
that. I'll go to the product
code next. Copyright license.

00:14:46.383 --> 00:14:47.149
OK, looks good.

00:14:50.459 --> 00:14:52.079
OK, let's look at the product
code.

00:14:54.729 --> 00:14:58.412
OK. What are we looking at here?
Maybe can I move the splitter a

00:14:58.412 --> 00:14:58.639
bit?

00:15:00.699 --> 00:15:01.829
Uh.

00:15:03.419 --> 00:15:05.159
OK, that kind of helps.

00:15:06.399 --> 00:15:09.236
It's a little bit small. Yeah.
OK, I know that's really small,

00:15:09.236 --> 00:15:11.309
but I'm mostly focused on the
code right now.

00:15:14.579 --> 00:15:18.824
OK, so what's happening here? We
got the classic original zip

00:15:18.824 --> 00:15:21.769
view. Iterator is now granting
friendship.

00:15:22.559 --> 00:15:25.770
And it is granting Tim highly
templated friendship. So

00:15:25.770 --> 00:15:28.339
unfortunately we do have to say
class here.

00:15:28.429 --> 00:15:31.209
Uh. Granting friendship to this
thing.

00:15:31.969 --> 00:15:35.049
Interesting. OK, so this should
all match template move

00:15:35.049 --> 00:15:38.349
constructible, under score
capital, funk import, range, dot

00:15:38.349 --> 00:15:39.779
under score capital views.

00:15:41.429 --> 00:15:45.197
I'm not super happy that this
has views. Instead of you types.

00:15:45.197 --> 00:15:47.949
I would prefer for this to be
exactly copied.

00:15:49.199 --> 00:15:53.379
Requires view of views and da,
da, da and size dot that thing

00:15:53.379 --> 00:15:57.626
is greater zero and as object V
here I'm just mentally diffing

00:15:57.626 --> 00:16:01.334
or visually diffing. Yeah, and
I'll looks good and can

00:16:01.334 --> 00:16:02.009
reference.

00:16:02.879 --> 00:16:06.630
Yep, that's all the same. It is
indeed a class. The only thing I

00:16:06.630 --> 00:16:10.035
have a concern with is views
versus view types. Maybe that

00:16:10.035 --> 00:16:13.440
was done to avoid wrapping. It
seems that these are almost

00:16:13.440 --> 00:16:16.845
exceeding 120 columns and that
if it said view type should

00:16:16.845 --> 00:16:20.423
wrap, my psychic power is is
they're telling me that this was

00:16:20.423 --> 00:16:21.289
the reason. So.

00:16:22.169 --> 00:16:25.132
Yeah, it's getting pretty close.
Uh. Maybe not too much. It's

00:16:25.132 --> 00:16:26.089
only mentioned once.

00:16:26.969 --> 00:16:29.919
If they said view futures, yeah,
that's the thing. I can't even

00:16:29.919 --> 00:16:32.684
spell. What's my brain doing?
No. Have you tried to totally

00:16:32.684 --> 00:16:32.869
fit?

00:16:34.169 --> 00:16:36.484
Yeah, this should. This should
be view types. I don't see any

00:16:36.484 --> 00:16:38.539
reason for them to differ. I'll
comment. It's an epic.

00:16:39.859 --> 00:16:40.689
Let me get this.

00:16:44.179 --> 00:16:46.789
Nitpick this says.

00:16:48.059 --> 00:16:55.349
Here I copy paste to avoid typos
views instead of view types I.

00:16:56.739 --> 00:16:57.639
Although.

00:17:01.709 --> 00:17:05.799
This has no mechanical
difference.

00:17:06.489 --> 00:17:11.539
But I would prefer to see the
UM.

00:17:13.909 --> 00:17:18.749
Friendship exactly match the
definition.

00:17:20.269 --> 00:17:22.952
OK Nitpicked this as views
instead of view types. This has

00:17:22.952 --> 00:17:25.726
no mechanical difference, but I
prefer to see the friendship

00:17:25.726 --> 00:17:28.364
exactly match the definition.
The only reason for them to

00:17:28.364 --> 00:17:29.229
differ would be is.

00:17:30.049 --> 00:17:33.647
If oh oh, that's right. OK,
there is a reason I just had to

00:17:33.647 --> 00:17:37.186
scroll up. We're not in a top
level class here. We're in a

00:17:37.186 --> 00:17:41.025
nested class. This is iterator
is Const, but it's nested within

00:17:41.025 --> 00:17:44.803
zip view and that is templated
on view types. OK, so you can't

00:17:44.803 --> 00:17:48.702
reuse the identifier view types
and in other situations. Usually

00:17:48.702 --> 00:17:52.601
when granting like shared putter
friendship to another type will

00:17:52.601 --> 00:17:56.499
say like other. So that's why I
was momentarily caught off guard

00:17:56.499 --> 00:17:58.239
when I didn't see other here.

00:17:58.869 --> 00:17:59.499
Umm.

00:18:00.779 --> 00:18:05.741
It is reasonable to say, oh oh,
there's a data member named

00:18:05.741 --> 00:18:09.049
views like whatever we choose,
we lose.

00:18:10.569 --> 00:18:14.299
Is this technically shadowing?
This is using the identifier.

00:18:15.469 --> 00:18:16.879
As a template parameter.

00:18:17.659 --> 00:18:20.169
And there's a data member name
views.

00:18:22.459 --> 00:18:24.616
I don't know if you can
necessarily take the decltype,

00:18:24.616 --> 00:18:26.499
but this is too close to
shadowing that I like.

00:18:27.759 --> 00:18:30.285
OK, so there's a reason for it
to be different, but I don't

00:18:30.285 --> 00:18:30.959
like views here.

00:18:32.719 --> 00:18:34.809
If it said other views, I would
be OK.

00:18:38.229 --> 00:18:40.459
Yeah, other views is probably
the simplest way to handle this.

00:18:44.519 --> 00:18:45.629
OK, let me rephrase this.

00:18:47.449 --> 00:18:47.899
Nitpick.

00:18:49.279 --> 00:18:51.189
I realized the.

00:18:52.669 --> 00:18:53.099
Let's see.

00:18:55.989 --> 00:19:00.859
I see that this is avoiding the
name.

00:19:02.009 --> 00:19:03.259
View types.

00:19:10.049 --> 00:19:10.449
Get back.

00:19:12.739 --> 00:19:18.169
I see that this is choosing a
different name for.

00:19:18.889 --> 00:19:19.899
View types.

00:19:20.939 --> 00:19:22.939
Which appears.

00:19:26.099 --> 00:19:31.269
In the parent class zip view
above.

00:19:32.129 --> 00:19:36.119
But this is slightly confusing
shadowing.

00:19:37.169 --> 00:19:40.119
Because the parent class has a.

00:19:40.779 --> 00:19:41.829
Views.

00:19:43.659 --> 00:19:49.489
Data member. I recommend
choosing another name.

00:19:52.889 --> 00:19:54.299
Such as.

00:19:55.949 --> 00:19:57.539
Under score other.

00:19:58.279 --> 00:20:00.129
Views. UM.

00:20:01.499 --> 00:20:05.964
We have a good example. Uh, let
me search in the repo real

00:20:05.964 --> 00:20:06.419
quick.

00:20:07.499 --> 00:20:11.187
Here we go. I was thinking other
ties where we usually see this

00:20:11.187 --> 00:20:12.109
with friendship.

00:20:13.089 --> 00:20:14.999
We we have an span.

00:20:15.929 --> 00:20:19.259
Of this is a converting
constructor. I think we might

00:20:19.259 --> 00:20:20.369
use tire Utah for.

00:20:21.149 --> 00:20:22.289
I shared putter.

00:20:23.449 --> 00:20:24.559
I think other views is fine.

00:20:26.939 --> 00:20:27.729
Which?

00:20:28.779 --> 00:20:31.379
Well, avoid all shadowing.

00:20:32.099 --> 00:20:38.714
And make the renames purpose
slightly more obvious. OK,

00:20:38.714 --> 00:20:39.659
perfect.

00:20:40.649 --> 00:20:43.003
Nitpick, I see that this is
choosing a different name for

00:20:43.003 --> 00:20:45.521
view types, which appears in the
parent class view above, but

00:20:45.521 --> 00:20:47.795
this is slightly confusing
shadowing because the parent

00:20:47.795 --> 00:20:50.434
class has a views data member. I
recommend choosing another name

00:20:50.434 --> 00:20:52.829
such as under score capital.
Other views, which will avoid

00:20:52.829 --> 00:20:55.144
all shadowing and make the
renames purpose slightly more

00:20:55.144 --> 00:20:55.469
obvious.

00:20:56.869 --> 00:20:57.169
OK.

00:20:57.899 --> 00:21:00.139
One declaration down, friend.

00:21:00.769 --> 00:21:03.767
Grant friendship to zip
transform view interesting that

00:21:03.767 --> 00:21:06.819
there's a relationship between
the iterators. We'll see.

00:21:07.859 --> 00:21:11.321
It's interesting that nothing
else is ohh if zip transfer of

00:21:11.321 --> 00:21:14.841
view needs to reach into this,
that's why. OK, so we're gonna

00:21:14.841 --> 00:21:18.360
expect zip transform view to
need that iterator. OK does have

00:21:18.360 --> 00:21:21.369
an interview. OK, it's gonna be
why. OK, so onwards.

00:21:23.559 --> 00:21:27.086
See, I know the standard is a
small here. I don't want the

00:21:27.086 --> 00:21:30.913
code to wrap if I can avoid it.
Maybe that's the best I can do.

00:21:30.913 --> 00:21:32.169
Maybe zoom out a bit.

00:21:33.009 --> 00:21:33.579
OK.

00:21:36.029 --> 00:21:39.360
OK, so we've got the export. As
previously mentioned, we've got

00:21:39.360 --> 00:21:41.339
let me switch over to highlight
here.

00:21:42.679 --> 00:21:46.805
OK, we've got a template move
constructible, F is move

00:21:46.805 --> 00:21:51.006
constructible, under score
capital funk input range dot

00:21:51.006 --> 00:21:55.883
under score, capital view types
OK. This requires that all those

00:21:55.883 --> 00:21:58.509
view types be a view and da da
da.

00:21:59.239 --> 00:22:03.761
And that we have more than zero
of them size of dot dot views is

00:22:03.761 --> 00:22:08.353
greater strictly Brian, Zero and
F which is funk has got to be an

00:22:08.353 --> 00:22:12.388
object type and we've gotta
satisfy the regular invocable

00:22:12.388 --> 00:22:16.702
concept funk ref. So it's gotta
be an L value function object

00:22:16.702 --> 00:22:18.929
range reference T views dot Yep.

00:22:19.739 --> 00:22:23.397
Here I'm making sure that we've
got all of the lvalue references

00:22:23.397 --> 00:22:26.717
and so forth because they are
important when asking all of

00:22:26.717 --> 00:22:30.319
these concept questions and our
internal helper concept for can

00:22:30.319 --> 00:22:33.921
reference the invoke result type
of funcraft, which is freff on

00:22:33.921 --> 00:22:37.242
range reference T. OK, so all
that exactly matches perfect

00:22:37.242 --> 00:22:38.649
class zip transform view.

00:22:39.459 --> 00:22:42.332
Ohh, I'm looking at the
iterator, but it matches the

00:22:42.332 --> 00:22:45.802
parent as well. Uh. Yeah, this
is gonna be exactly the same. So

00:22:45.802 --> 00:22:46.019
Yep.

00:22:46.899 --> 00:22:50.336
Classic transform view there is
publicly from view interface

00:22:50.336 --> 00:22:52.929
that transform view function
view types. Yep.

00:22:53.849 --> 00:22:57.498
OK, so private data members and
whoops, sorry aliases using

00:22:57.498 --> 00:23:01.209
under score capital interview is
zip view of view types dot.

00:23:02.109 --> 00:23:06.219
OK, so that is this interview
exposition only.

00:23:07.719 --> 00:23:11.390
And then coming down, unique
counteracts, which we'll use

00:23:11.390 --> 00:23:15.252
someday movable box, our helper
machinery templated on funk,

00:23:15.252 --> 00:23:18.924
this one called under score
capital function. OK and then

00:23:18.924 --> 00:23:22.659
we've got the interview named
under score Capital ZIP, OK.

00:23:24.099 --> 00:23:25.189
And then.

00:23:25.859 --> 00:23:28.857
We've got these separator and
the Sentinel. I think these are

00:23:28.857 --> 00:23:30.889
actually the same names as in
the others.

00:23:32.079 --> 00:23:33.509
But they're actually in the
standard.

00:23:35.129 --> 00:23:35.599
That's great.

00:23:36.849 --> 00:23:41.339
OK, so template and we'll const
using under score capital zip

00:23:41.339 --> 00:23:45.685
erator is an iterator, T maybe
Const is const interview and

00:23:45.685 --> 00:23:49.958
then template on bool is Const.
Still ugly Sentinel as the

00:23:49.958 --> 00:23:54.159
Sentinel test of maybe consists
const interview. OK good.

00:23:55.089 --> 00:23:56.299
And then.

00:23:57.049 --> 00:24:01.062
We've got the template boys
Const. Our category base that's

00:24:01.062 --> 00:24:04.742
going to help with getting piped
defs. I guess this is

00:24:04.742 --> 00:24:06.749
specialized specialized below.

00:24:07.959 --> 00:24:11.929
Iterator. Sorry, I'm scanning
below. Here's a Sentinel.

00:24:13.439 --> 00:24:17.659
Ah, do we ever specialize? OK.

00:24:19.239 --> 00:24:21.564
Let's see, where do we
specialize? Ohh no, this

00:24:21.564 --> 00:24:23.938
specialization is immediately
below. Yay reading

00:24:23.938 --> 00:24:27.039
comprehension. I was just like I
was expecting something small.

00:24:27.039 --> 00:24:29.947
And so when I saw this big
thing, my eyes just glazed right

00:24:29.947 --> 00:24:32.757
over it. OK, so we got category
base. We'll see what this

00:24:32.757 --> 00:24:35.858
machine is doing. This is going
to be needed for presumably the

00:24:35.858 --> 00:24:37.409
iterator. Yes, the iterator. OK.

00:24:38.229 --> 00:24:39.879
So let's start reviewing the
iterator.

00:24:40.979 --> 00:24:41.499
Down here.

00:24:42.589 --> 00:24:44.679
OK, so template on both Const.

00:24:45.609 --> 00:24:47.159
Is it transform view iterator?

00:24:49.159 --> 00:24:49.549
OK.

00:24:50.149 --> 00:24:53.409
And then iterator category is
the thing that's not always

00:24:53.409 --> 00:24:53.859
present.

00:24:55.139 --> 00:24:58.326
OK, here we go. The member
Typedef name iterator category

00:24:58.326 --> 00:25:01.349
is defined if and only if it
models forward range, so.

00:25:02.099 --> 00:25:03.329
The specialization.

00:25:04.149 --> 00:25:07.819
On template Bullis constant
requires forward range.

00:25:08.499 --> 00:25:13.882
Umm, the base scrolling up which
is maybe Const interview? Maybe

00:25:13.882 --> 00:25:15.539
Conn's interview OK.

00:25:16.519 --> 00:25:20.851
So when that's met, then we have
the iterator category, so that's

00:25:20.851 --> 00:25:22.099
why I'm doing here.

00:25:23.029 --> 00:25:26.500
OK, let me go down Umm so base
models forward range which it

00:25:26.500 --> 00:25:29.859
does and in that case it or
categories defined as follows.

00:25:29.859 --> 00:25:31.339
OK so we've got this here.

00:25:32.069 --> 00:25:35.649
Umm using iterator category, so
this is.

00:25:37.339 --> 00:25:41.379
Wow. Uh, that's a big Lambda
using iterator categories. The

00:25:41.379 --> 00:25:44.949
decal type of an immediate
invocation of this puppy.

00:25:46.399 --> 00:25:47.309
Praise print, print.

00:25:48.199 --> 00:25:50.663
So we're doing a lot of
computation here. This looks

00:25:50.663 --> 00:25:53.639
horrible, but it would have been
way, way more horrible without

00:25:53.639 --> 00:25:56.429
lambdas and decltype, and if
constexpr. So this is actually

00:25:56.429 --> 00:25:57.499
not as bad as it seems.

00:25:58.919 --> 00:26:01.756
And it's mapping all these
bullet points, hopefully pretty

00:26:01.756 --> 00:26:03.729
straightforwardly. OK, we have a
Lambda.

00:26:04.539 --> 00:26:07.682
The no except here is kind of
unnecessary because it's the

00:26:07.682 --> 00:26:10.559
type computation, but it's not
wrong, so that's fine.

00:26:14.299 --> 00:26:20.211
Let's see if. OK, so invoke T
under score cabinet. Invoke T is

00:26:20.211 --> 00:26:24.529
the invoke result of maybe Const
Const F ref.

00:26:25.429 --> 00:26:29.970
Invoked on a range reference T
maybe cons is Conn's view types

00:26:29.970 --> 00:26:30.259
dot.

00:26:31.099 --> 00:26:34.907
OK, here's here's one of what
I'm checking for is. Is there

00:26:34.907 --> 00:26:38.843
any obnoxious repetition that
could be extracted out? There's

00:26:38.843 --> 00:26:39.669
a little bit.

00:26:41.499 --> 00:26:44.504
And this may be const. Ohh no,
it's it's not really

00:26:44.504 --> 00:26:48.261
extractable. This is being pack
expanded because there's a whole

00:26:48.261 --> 00:26:51.844
bunch of you types we need to
spam out range reference key of

00:26:51.844 --> 00:26:55.196
maybe Const is view 0, maybe
Const is Const view one blah

00:26:55.196 --> 00:26:58.491
blah blah over and over. This
one is expanding something

00:26:58.491 --> 00:27:02.016
completely different derived
from and dot dot dot so there's

00:27:02.016 --> 00:27:05.715
no extraction possible with like
a type def. That's best we can

00:27:05.715 --> 00:27:05.889
do.

00:27:07.109 --> 00:27:08.569
With without like an alias
template.

00:27:09.559 --> 00:27:13.479
OK, so that's good. If that
thing is OK, we've got that

00:27:13.479 --> 00:27:14.459
invoke result.

00:27:15.279 --> 00:27:18.839
If it is not a reference, not is
reference V.

00:27:19.569 --> 00:27:23.801
Then the iterator category this
Lambda is going to return input

00:27:23.801 --> 00:27:27.835
iterator tag OK if constexpr,
else otherwise. So this is the

00:27:27.835 --> 00:27:28.629
else branch.

00:27:29.309 --> 00:27:29.749
Umm.

00:27:30.409 --> 00:27:33.495
We're going to have a context
for auto. We've got a nested

00:27:33.495 --> 00:27:36.529
Lambda here, and then we're
going to do a bunch of stuff.

00:27:37.529 --> 00:27:38.409
Interesting.

00:27:40.289 --> 00:27:44.566
And we're feeding it an explicit
template argument rather than

00:27:44.566 --> 00:27:45.449
tag dispatch.

00:27:48.209 --> 00:27:52.494
Yeah, it's it's horrible and
syntax, but it's reasonable. OK,

00:27:52.494 --> 00:27:56.779
so let's seize denote the packet
types, iterator traits blah.

00:27:58.249 --> 00:28:00.799
OK, so this is asking.

00:28:02.409 --> 00:28:06.625
That's this thing iterator
traits of iterator T. Maybe

00:28:06.625 --> 00:28:08.619
Const is const of U types.

00:28:09.599 --> 00:28:10.069
OK.

00:28:11.299 --> 00:28:16.129
So seizes that. Oh, and we need
the iterator category, so type

00:28:16.129 --> 00:28:19.349
name iterator category. So this
is the C.

00:28:21.649 --> 00:28:25.355
Which we can't just extract as
at the pack. So this is saying

00:28:25.355 --> 00:28:29.182
concepts per auto, under score,
capital check, tag type closure

00:28:29.182 --> 00:28:32.411
where Lambda taking template on
a tape name tag type.

00:28:32.411 --> 00:28:35.639
Conventionally we always say
class here, but explicit

00:28:35.639 --> 00:28:39.406
template parameters for lambdas
are so novel. I don't you know

00:28:39.406 --> 00:28:41.559
if we have any of the product
code.

00:28:43.439 --> 00:28:47.441
I personally prefer type name.
We just tried to enforce code

00:28:47.441 --> 00:28:49.869
conventions. Do we have any
lambdas?

00:28:48.169 --> 00:28:49.459
Should this nested landed?

00:28:50.249 --> 00:28:52.839
Should this nested land to be a
variable template instead?

00:28:54.139 --> 00:28:57.214
It feels like it could OK, we
only have one and it's in the,

00:28:57.214 --> 00:28:59.987
UM, one occurrence of
tightening. At least it's in the

00:28:59.987 --> 00:29:03.013
test. It's a good question
whether it could be V elsewhere.

00:29:03.013 --> 00:29:05.988
We have used class. OK, so I
think stylistically asked for

00:29:05.988 --> 00:29:09.164
class, but you've got the better
question rather than my silly

00:29:09.164 --> 00:29:12.089
syntax level question. Could
this be a variable template?

00:29:10.239 --> 00:29:10.859
The pencil.

00:29:13.409 --> 00:29:16.369
In which case we wouldn't need
this horribleness.

00:29:16.949 --> 00:29:19.239
Umm, but we left this out.

00:29:17.909 --> 00:29:19.079
Yeah, that, that's.

00:29:20.489 --> 00:29:21.089
Yeah.

00:29:21.979 --> 00:29:25.388
The explicit template argument
list for a Lambda is just a

00:29:22.769 --> 00:29:23.099
Every.

00:29:25.388 --> 00:29:25.909
horrible.

00:29:26.029 --> 00:29:26.439
It's.

00:29:26.599 --> 00:29:29.204
Yeah, it's syntactically horror.
I mean, it's a very clever

00:29:29.204 --> 00:29:32.071
solution. So like this is and it
it's definitely it's translating

00:29:32.071 --> 00:29:34.676
the machinery in the standard
well, so no complaints there.

00:29:34.676 --> 00:29:37.109
But if we could simplify it,
that would be even better.

00:29:38.349 --> 00:29:41.910
What does this depend on in the
the usual sense, the word we

00:29:41.910 --> 00:29:45.588
care about, we've already got
the is Const. We've got the view

00:29:45.588 --> 00:29:45.939
types.

00:29:46.439 --> 00:29:49.309
Umm. If we made it a variable
template?

00:29:47.519 --> 00:29:50.451
The enclosing Lambda is not
generic, so it's not dependent

00:29:50.451 --> 00:29:52.539
on any template parameters of
that Banta.

00:29:53.439 --> 00:29:56.491
It's the best the class, the
class template arguments and

00:29:53.449 --> 00:29:54.319
Yeah, good point.

00:29:55.669 --> 00:29:56.059
Yeah.

00:29:56.491 --> 00:29:57.649
whatever the internal.

00:29:57.029 --> 00:29:57.889
There is constant.

00:29:58.609 --> 00:30:00.539
And if you're types out here.

00:29:58.739 --> 00:29:59.799
Manda template.

00:30:01.239 --> 00:30:02.619
Yeah, with the.

00:30:01.249 --> 00:30:03.997
So it could be a static
constexpr class memory variable

00:30:03.997 --> 00:30:04.439
template.

00:30:05.999 --> 00:30:06.719
Yeah. OK.

00:30:07.399 --> 00:30:10.836
But rather than completely top
level being static, constexpr be

00:30:10.836 --> 00:30:14.220
good and this is C plus latest
so we don't need to worry about

00:30:14.220 --> 00:30:17.389
Clr pure, which is really really
hates variable templates.

00:30:17.829 --> 00:30:20.959
Umm, so I think that would be
good.

00:30:21.729 --> 00:30:24.884
How then would there be any
other robots to simplifying

00:30:24.884 --> 00:30:28.377
this? It would be you've got
your V here templated on the tag

00:30:28.377 --> 00:30:28.659
type.

00:30:29.349 --> 00:30:33.926
And it would just be a bull that
would be this. It would need to

00:30:33.926 --> 00:30:34.419
return.

00:30:35.169 --> 00:30:37.369
And then we would if constexpr
Brit.

00:30:37.999 --> 00:30:41.685
Yeah, yeah, I think it would be
strictly simpler, because mainly

00:30:41.685 --> 00:30:45.371
we'd be getting rid of this bit
and the syntax involved invoking

00:30:45.371 --> 00:30:48.717
it and we wouldn't need to
return, it would just be equals

00:30:48.717 --> 00:30:52.063
blah. We might still need to
suppress clang format, but it

00:30:52.063 --> 00:30:55.069
should generally be good. OK, so
let's come on this.

00:30:58.329 --> 00:30:58.799
OK.

00:31:03.879 --> 00:31:08.184
Thinking should we have a
separate syntax in a PIC and a

00:31:08.184 --> 00:31:12.490
style in the pick? I'll say
syntax nitpick first just on

00:31:12.490 --> 00:31:14.379
this line syntax nitpick.

00:31:14.679 --> 00:31:20.629
Umm, this says I'm type name,
but we conventionally say.

00:31:22.239 --> 00:31:24.649
Class in product code.

00:31:27.659 --> 00:31:31.264
OK. And then the actual much
more important semantic nitpick

00:31:31.264 --> 00:31:34.869
or not really semantic, it's
more like implementation style.

00:31:36.669 --> 00:31:37.259
This.

00:31:38.779 --> 00:31:40.389
Is correct.

00:31:41.089 --> 00:31:47.356
And a fairly straightforward
transformation of the standard

00:31:47.356 --> 00:31:47.879
ease.

00:31:48.479 --> 00:31:49.169
Umm.

00:31:49.999 --> 00:31:53.049
But passing on.

00:31:53.739 --> 00:31:58.509
Explicit template argument to a
Lambda is.

00:31:59.289 --> 00:32:01.649
Relatively unusual.

00:32:02.879 --> 00:32:03.529
And.

00:32:04.249 --> 00:32:05.059
Verbose.

00:32:05.859 --> 00:32:13.329
As all of the call sites below
need template disambiguator.

00:32:14.239 --> 00:32:14.979
Umm.

00:32:17.069 --> 00:32:21.339
I'm eating you, Casey. No, it's
uh. There we go at Casey Carter.

00:32:22.779 --> 00:32:26.837
At Casey, Carter would have said
her rific instead of unusual and

00:32:23.029 --> 00:32:23.909
Observed.

00:32:26.837 --> 00:32:28.989
ferbus, but your mileage may
vary.

00:32:27.339 --> 00:32:28.429
Or horrific.

00:32:36.199 --> 00:32:36.769
Yeah.

00:32:43.689 --> 00:32:51.973
Observed having too much fun
here that this could instead be

00:32:51.973 --> 00:32:59.986
written as a static constexpr
variable template within the

00:32:59.986 --> 00:33:01.209
scope of.

00:33:03.239 --> 00:33:05.389
Category based is Const.

00:33:06.089 --> 00:33:07.959
Yeah, because we should just be
able to.

00:33:09.539 --> 00:33:12.444
Put it like right before or no,
it's got to be before the

00:33:12.444 --> 00:33:14.849
iterator category because this
is the type def.

00:33:15.339 --> 00:33:19.718
Umm, within this scope of
category based cons, would this

00:33:19.718 --> 00:33:21.229
Lambda then need to?

00:33:23.519 --> 00:33:25.589
But you need to capture it. I
sure hope not.

00:33:28.159 --> 00:33:30.379
Because we're within a Lambda
invocation here.

00:33:30.769 --> 00:33:33.039
Capture I'd a variable template,
no?

00:33:31.159 --> 00:33:31.999
If we had a static.

00:33:33.959 --> 00:33:36.969
OK, because it's not a local
variable, OK.

00:33:36.789 --> 00:33:38.826
Well, yeah, yeah, it's not a
functional look. We can't

00:33:38.826 --> 00:33:40.789
capture anything that's not a
function local anyway.

00:33:41.179 --> 00:33:44.036
OK, OK, I I forget how this
language works. There's there's

00:33:44.036 --> 00:33:44.799
too many things.

00:33:47.069 --> 00:33:50.254
Yeah. Thank you for explaining.
Uh, yeah, I know. It's just

00:33:47.529 --> 00:33:48.759
You have the silly language.

00:33:50.254 --> 00:33:53.706
like, you know, 3000 something,
pages of standardese all crammed

00:33:53.706 --> 00:33:56.945
in my brain. OK, so stay at
constexpr within the scope scope

00:33:56.945 --> 00:33:58.379
of category based is Const.

00:34:01.069 --> 00:34:02.619
I'm then.

00:34:05.459 --> 00:34:07.229
Let's say static constexpr bool.

00:34:07.899 --> 00:34:12.989
Umm. Then the definition
wouldn't need.

00:34:13.629 --> 00:34:21.189
Return instead. It would simply
provide the value of the bool.

00:34:23.879 --> 00:34:25.249
As it's initializer.

00:34:26.329 --> 00:34:29.619
And the usages below.

00:34:30.359 --> 00:34:31.629
Wouldn't need.

00:34:33.089 --> 00:34:35.009
Template operator prinn pren.

00:34:37.419 --> 00:34:38.099
Like this?

00:34:39.679 --> 00:34:41.159
The rest of the code.

00:34:42.189 --> 00:34:43.449
Would remain.

00:34:44.299 --> 00:34:44.999
Basically.

00:34:46.089 --> 00:34:49.004
Unchanged. OK. Uh has a sound.
This is correct and a fairly

00:34:49.004 --> 00:34:51.579
straightforward transformation
of the standard ease.

00:34:53.389 --> 00:34:57.543
I do want to make clear that
this is uh, up at a hard ice cat

00:34:57.543 --> 00:34:57.879
here.

00:35:00.069 --> 00:35:02.961
Because I like straightforward
transformations otherwise, then

00:35:02.961 --> 00:35:05.762
my brain has to work figuring
out what's going on here. This

00:35:05.762 --> 00:35:08.287
is correct and a fairly
straightforward transformation

00:35:08.287 --> 00:35:10.951
of the standardized cat, but
passing an explicit template

00:35:10.951 --> 00:35:13.476
argument to a Lambda is
relatively unusual and verbose

00:35:13.476 --> 00:35:16.369
is all the call types below need
template disambiguator Casey,

00:35:16.369 --> 00:35:19.261
who created characterized this
as horrific, observed that this

00:35:19.261 --> 00:35:22.062
could instead be written as a
static constexpr bool variable

00:35:22.062 --> 00:35:24.817
template within the scope of
category basis Const. Then the

00:35:24.817 --> 00:35:27.710
definition would need return.
Instead, it would simply provide

9c93b676-e558-4ae6-b8d1-135e090ff3ce/4932-10
00:35:27.710 --> 00:35:29.639
the value of the bool as its
initializer.

00:35:30.229 --> 00:35:32.717
And the usages below wouldn't
need template operator print

00:35:32.717 --> 00:35:35.459
print the rest of the code would
remain basically unchanged. OK.

00:35:36.979 --> 00:35:40.559
OK, so derive from blah random
access or tag. This is what this

00:35:40.559 --> 00:35:44.083
is doing 3 different times. I do
appreciate that it's all been

00:35:44.083 --> 00:35:44.699
lifted out.

00:35:45.549 --> 00:35:46.509
OK so.

00:35:47.779 --> 00:35:51.309
If Constexpr check for random
access iterator tag. Oh, that's

00:35:51.309 --> 00:35:54.669
just what this is doing, ran it,
ran it, bite it, bite it,

00:35:54.669 --> 00:35:57.801
forward it, forward it,
otherwise input so ran it, ran

00:35:57.801 --> 00:36:01.103
it, bite it, bite it for it,
forward it, otherwise import

00:36:01.103 --> 00:36:02.869
error tag. OK, bunch of braces.

00:36:04.609 --> 00:36:06.649
OK, good. So that's all this
stuff.

00:36:09.319 --> 00:36:12.712
OK, then we've got. What is this
the non constrained one? No,

00:36:12.712 --> 00:36:15.886
this is the one that's going to
use the category base. So

00:36:15.886 --> 00:36:19.279
category based only provides
iterator category conditionally.

00:36:19.279 --> 00:36:21.469
Everything else is extracted
down here.

00:36:22.359 --> 00:36:24.129
OK, so let's go down here.

00:36:26.489 --> 00:36:29.163
OK, ranges. This is the zip
transform view iterator, so

00:36:29.163 --> 00:36:32.076
that's what we're looking at
here. Template will under score

00:36:32.076 --> 00:36:34.990
kept is cons class, under score
cap iterator drives publicly

00:36:34.990 --> 00:36:37.473
from category basis, cons to
private stuff we grant

00:36:37.473 --> 00:36:37.999
friendship.

00:36:38.869 --> 00:36:40.179
To our parents of transform
view.

00:36:41.069 --> 00:36:44.359
We're just correct. Parent needs
friendship in order to access.

00:36:45.049 --> 00:36:47.484
Our data Members and other stuff
here, but this can access

00:36:47.484 --> 00:36:50.044
private members of the parent
just fine because it's a member

00:36:50.044 --> 00:36:50.829
like any other. OK?

00:36:52.549 --> 00:36:57.989
Then some typedefs using parent
tea is maybe Const is const for

00:36:57.989 --> 00:37:02.919
zip transform view using base T
is maybe Const interview.

00:37:03.689 --> 00:37:08.219
Parents Starr or parent star
under score kept parent is null

00:37:08.219 --> 00:37:08.739
putter.

00:37:09.499 --> 00:37:10.289
And then.

00:37:11.689 --> 00:37:15.100
Coming out no unique address
because the pointer is always

00:37:15.100 --> 00:37:18.627
going to occupy memory. Zip
erator is Const under score kept

00:37:18.627 --> 00:37:20.189
inner. OK, that's all good.

00:37:20.809 --> 00:37:22.099
And then we have a constructor.

00:37:23.539 --> 00:37:26.079
Constexpr iterator constructor.

00:37:26.819 --> 00:37:29.209
Taking apparently ref under
parent under.

00:37:30.199 --> 00:37:32.399
And then a zipper rator is
const.

00:37:33.099 --> 00:37:33.669
Inner.

00:37:34.629 --> 00:37:36.804
OK, we don't have to type for
that and that's under inner

00:37:36.804 --> 00:37:37.179
owner, OK.

00:37:37.839 --> 00:37:40.865
And then we are conditionally
noexcept strengthen because it

00:37:40.865 --> 00:37:43.991
appears in the standard. Because
of this constructor signature

00:37:43.991 --> 00:37:46.919
appears in the standard. We're
no except when and here I'm

00:37:46.919 --> 00:37:50.094
checking for two noexcept, which
there aren't. Good is no throw

00:37:50.094 --> 00:37:53.170
move constructible V zip reader
is const because we're moving

00:37:53.170 --> 00:37:53.419
that.

00:37:54.689 --> 00:37:58.533
Said parent to be tested at
Arsov. This thing that we passed

00:37:58.533 --> 00:38:02.567
by reference set inner to be a
stood move of under inner honor.

00:38:02.567 --> 00:38:03.639
OK, public stuff.

00:38:04.349 --> 00:38:04.749
OK.

00:38:04.859 --> 00:38:08.296
So we've got the iterator
category provided by the base,

00:38:08.296 --> 00:38:10.829
not always present in the public
section.

00:38:11.949 --> 00:38:16.168
Using iterator concept is type
name. Zip erator is Const

00:38:16.168 --> 00:38:17.649
iterator concept OK.

00:38:18.549 --> 00:38:23.171
Using value type remove C VFT
invoke result T maybe Const is

00:38:23.171 --> 00:38:27.793
Const. Funk Ref Ranger reference
T maybe Const is Const view

00:38:27.793 --> 00:38:28.779
types dot OK.

00:38:29.949 --> 00:38:31.639
I'm not even selecting taxes
good enough.

00:38:32.869 --> 00:38:36.829
Using difference type is range
difference T based T OK that's

00:38:36.829 --> 00:38:37.149
good.

00:38:38.729 --> 00:38:39.839
Iterator prinn pren.

00:38:41.849 --> 00:38:43.849
OK, this is getting a no except.

00:38:44.889 --> 00:38:46.929
But the standard just says
default.

00:38:50.909 --> 00:38:52.459
I wonder if this is actually
necessary.

00:38:55.159 --> 00:38:57.455
It feels like it shouldn't.
Shouldn't be. I feel like we

00:38:57.455 --> 00:38:59.752
should just say what the
standard says, just default it.

00:38:59.752 --> 00:39:02.290
There's no reason to like have
an error if this thing's wrong,

00:39:02.290 --> 00:39:04.748
because it's always gonna be
right. If we've got it correct.

00:39:04.748 --> 00:39:07.085
No, except is no third defect
extractable V. Zip rater is

00:39:07.085 --> 00:39:08.939
const. That's the only thing
that could fail.

00:39:09.869 --> 00:39:13.462
Umm, this is verbose enough that
I think I'm going to ask for the

00:39:13.462 --> 00:39:14.769
no except to be removed.

00:39:15.929 --> 00:39:18.270
It is. I mean it's correct and
it's even not strengthening. It

00:39:18.270 --> 00:39:19.349
does match the standard, but.

00:39:20.029 --> 00:39:21.329
I think we should just say
default.

00:39:24.289 --> 00:39:31.549
All this is correct. I think
that's simply omitting the.

00:39:32.679 --> 00:39:33.999
No, except.

00:39:35.279 --> 00:39:36.429
Specification.

00:39:37.089 --> 00:39:38.579
Would be reasonable.

00:39:39.909 --> 00:39:40.599
As.

00:39:41.629 --> 00:39:48.346
It exactly matches what the
compiler will generate and the

00:39:48.346 --> 00:39:51.079
standard simply depicts.

00:39:52.629 --> 00:39:54.639
Copy paste. Yep, I'm not in
selection.

00:39:56.479 --> 00:39:57.629
Yeah, this thing.

00:40:01.379 --> 00:40:02.309
OK, how's it look?

00:40:03.679 --> 00:40:06.485
Back to highlight, while this is
correct, I think that simply

00:40:06.485 --> 00:40:08.884
omitting the no excess
specification would be excuse

00:40:08.884 --> 00:40:11.600
me. While this is correct, I
think that simply emitting the

00:40:11.600 --> 00:40:14.588
no excess specification would be
reasonable as it exactly matches

00:40:14.588 --> 00:40:17.485
what the compiler will generate
and the standard simply depicts

00:40:17.485 --> 00:40:18.889
Iterator Prinn Pren is default.

00:40:19.499 --> 00:40:19.749
OK.

00:40:20.679 --> 00:40:26.700
Umm, still public stuff. We have
a constexpr constructor iterator

00:40:26.700 --> 00:40:32.539
from iterator not is Const. I is
becoming under score kept RSS.

00:40:33.229 --> 00:40:37.544
We have a strengthening, so this
is no except when is nothrow

00:40:37.544 --> 00:40:38.519
convertible V.

00:40:39.179 --> 00:40:39.809
From.

00:40:41.489 --> 00:40:43.109
Zipper rator of false.

00:40:43.839 --> 00:40:45.419
To zip rator is const.

00:40:49.069 --> 00:40:49.889
That's interesting.

00:40:51.789 --> 00:40:54.883
This is being written in a
dependent way, which is probably

00:40:54.883 --> 00:40:58.029
good so that it's delayed until
we actually instantiate this

00:40:58.029 --> 00:40:58.339
thing.

00:40:59.799 --> 00:41:03.378
This requires this count, so we
know we are Const. Our source is

00:41:03.378 --> 00:41:06.792
non consumer. Adding constants
to it. So convertible from non

00:41:06.792 --> 00:41:10.151
cons to us and we know where
Const OK so that is the correct

00:41:10.151 --> 00:41:11.749
direction, it's not reversed.

00:41:12.409 --> 00:41:16.018
Umm. OK. So again we watching
the standard requires is const

00:41:16.018 --> 00:41:19.391
and convertible 2 zip, rater
false, zip, rater Const OK.

00:41:19.391 --> 00:41:22.941
That's why it's written that
way. The standard has this zip

00:41:22.941 --> 00:41:26.551
rater falls, zip raters const
and then the no except matches

00:41:26.551 --> 00:41:30.102
that but changes the concept
convertible to to is no throw.

00:41:30.102 --> 00:41:32.469
Convertible V type track which
is good.

00:41:33.889 --> 00:41:37.372
And then construct. This is not
super surprising down here,

00:41:37.372 --> 00:41:37.779
parent.

00:41:38.539 --> 00:41:40.149
Uh RHS parent?

00:41:40.939 --> 00:41:45.014
For storing pointers, so we
don't need this address of stuff

00:41:45.014 --> 00:41:48.689
here and then inner stood move
art to center. OK good.

00:41:50.459 --> 00:41:52.029
OK then.

00:41:52.989 --> 00:41:56.529
Ah, it's gonna hear. No, that
was the that was different.

00:41:59.489 --> 00:42:02.146
One even looking at here why?
Where did this come from? Oh,

00:42:02.146 --> 00:42:04.759
no. This was the this one. OK.
This is the address of. I'm

00:42:04.759 --> 00:42:06.619
getting confused. This is the
address of.

00:42:07.319 --> 00:42:09.019
Umm, here's the conversion.

00:42:10.179 --> 00:42:12.783
The conversion simply says
parent type parent innertube

00:42:12.783 --> 00:42:13.249
Venner OK.

00:42:14.559 --> 00:42:19.349
OK, back In Sync. Now operator
dref, that's up here.

00:42:21.349 --> 00:42:24.650
So we're adding notice card
because DRF is always notice

00:42:24.650 --> 00:42:28.299
card constexpr. Decltype auto
offer draft Const no except. See

00:42:28.299 --> 00:42:29.689
below. Let's check that.

00:42:30.999 --> 00:42:32.839
Ah Umm.

00:42:33.039 --> 00:42:36.417
Umm, the exact specification is
equivalent to no except horrible

00:42:36.417 --> 00:42:36.729
thing.

00:42:39.169 --> 00:42:40.139
But that's just the body.

00:42:41.539 --> 00:42:42.609
Except invoke.

00:42:45.629 --> 00:42:48.900
Yeah, it's literally just the
body, O contrino, except if no

00:42:48.900 --> 00:42:52.224
except stood apply, dereference,
closure, prinn, pren it. OK,

00:42:52.224 --> 00:42:55.442
that's fine. I really wish we
had no except auto returns to

00:42:55.442 --> 00:42:56.729
deeply exact same thing.

00:42:58.639 --> 00:43:01.387
Yeah, for everything there,
invoke. I guess that we're going

00:43:01.387 --> 00:43:02.109
to see what the.

00:43:03.049 --> 00:43:05.079
He reference closure has is up
below.

00:43:06.649 --> 00:43:08.449
Excuse me. Yeah, it's below.

00:43:09.069 --> 00:43:09.609
Here's this.

00:43:10.679 --> 00:43:12.129
Horrible Empire thing, OK?

00:43:13.449 --> 00:43:15.819
Here and funny. OK, that's good.
Let's go back.

00:43:16.289 --> 00:43:17.739
Umm here.

00:43:19.199 --> 00:43:20.279
OK, that's looking good.

00:43:24.659 --> 00:43:28.481
OK, more iterator operations.
UM, just looking at the

00:43:28.481 --> 00:43:30.889
definitions here rather than
the.

00:43:32.599 --> 00:43:36.669
Passed snaps and I'll go back up
and highlight that constexpr

00:43:36.669 --> 00:43:40.673
here not nodiscard constexpr
iterator ref operator plus plus

00:43:40.673 --> 00:43:44.809
strengthening to be no except
when no except plus a Sinner OK.

00:43:45.429 --> 00:43:48.299
Uh also center turned off this.

00:43:53.539 --> 00:43:55.684
I'm I'm look at my brain is
short circuiting cause I'm

00:43:55.684 --> 00:43:58.181
seeing these braces on their own
line. I'm like oh, that should

00:43:58.181 --> 00:44:00.443
be a slash star rather than
slash slash so that the brace

00:44:00.443 --> 00:44:01.419
can go on the right line.

00:44:02.549 --> 00:44:06.382
I'm going to grudgingly refrain
commenting about that. Plus the

00:44:06.382 --> 00:44:08.239
Sinner return to your for this.

00:44:09.519 --> 00:44:11.609
Trying to be a little bit less
into picky in the new year.

00:44:12.809 --> 00:44:16.279
Uh. Constexpr void whoops.
Operator plus int. Again

00:44:16.279 --> 00:44:18.949
strengthening, no, except if no
except.

00:44:20.439 --> 00:44:23.780
Plus plus this is void, so guess
expert void operator plus

00:44:23.780 --> 00:44:27.064
assent. We're no exceptive
noexcept, can we say plus plus

00:44:27.064 --> 00:44:30.405
to deco Val iterator ref,
because we can't easily say this

00:44:30.405 --> 00:44:30.689
here.

00:44:31.989 --> 00:44:35.572
I vaguely recall this is like
subject to some compiler bug or

00:44:35.572 --> 00:44:39.097
something, but wait, this is
weird. Let's even going on here

00:44:39.097 --> 00:44:39.329
cuz.

00:44:40.079 --> 00:44:42.419
This says no except plus plus
zero for this.

00:44:43.429 --> 00:44:46.529
So why are these different? I
would I would understand if one

00:44:46.529 --> 00:44:48.779
couldn't say it, but the other
that's weird.

00:44:51.899 --> 00:44:53.669
They should really be identical.

00:44:59.119 --> 00:45:00.509
Yeah, I'm gonna come about this.

00:45:05.299 --> 00:45:07.649
They are the same expression,
it's just this once constrained.

00:45:08.459 --> 00:45:09.129
Why?

00:45:09.839 --> 00:45:12.439
That neither a template, this
one is constrained but.

00:45:13.369 --> 00:45:14.819
Yeah. OK. Comment.

00:45:18.889 --> 00:45:22.859
See uh copy this inner bit prime
prime paren.

00:45:23.729 --> 00:45:29.879
This says blah, but the next
overload says.

00:45:30.639 --> 00:45:31.149
Law.

00:45:33.159 --> 00:45:35.429
Could the former?

00:45:38.339 --> 00:45:39.449
Do the.

00:45:41.239 --> 00:45:46.840
Or could we use? Or could we
avoid? I wanna be unambiguous

00:45:46.840 --> 00:45:48.549
deco Val for both.

00:45:49.609 --> 00:45:52.286
OK, this says no except plus
plus Taco Bell stuff, but the

00:45:52.286 --> 00:45:55.009
next overload says no except
plus plus dear. If this, could

00:45:55.009 --> 00:45:56.099
we avoid equal for both?

00:45:58.469 --> 00:46:02.157
So this one just says plus
posterior for this. OK. Next

00:46:02.157 --> 00:46:06.241
again no, no discard constexpr
return iterator by value. I'll

00:46:06.241 --> 00:46:10.193
plus percent strengthening.
We're noexcept when is no throw

00:46:10.193 --> 00:46:14.409
compostable V iterator because
we got a return ourselves and no

00:46:14.409 --> 00:46:18.295
except plus to your for this
strengthened requires support

00:46:18.295 --> 00:46:20.799
range of base T effects
equivalent 2.

00:46:21.639 --> 00:46:23.409
Auto temp is due for this.

00:46:25.039 --> 00:46:25.689
Increment.

00:46:26.409 --> 00:46:27.189
Return temp.

00:46:27.829 --> 00:46:29.899
There's kind of a spurious new
line there.

00:46:30.599 --> 00:46:31.769
I will refrain.

00:46:32.359 --> 00:46:34.869
Ah, constexpr or iterator ref.

00:46:35.609 --> 00:46:36.779
Uh, minus minus.

00:46:38.849 --> 00:46:40.669
Strengthening, no, except if no
except.

00:46:41.489 --> 00:46:43.959
3 decater inner OK.

00:46:44.889 --> 00:46:45.519
Strengthened.

00:46:46.179 --> 00:46:49.746
Requires bidirectional Orange
base predict inner return to

00:46:49.746 --> 00:46:51.319
your this OK, that's good.

00:46:57.799 --> 00:47:00.393
OK, I can't resist. I got a
comment about this new line.

00:47:00.393 --> 00:47:01.349
It's driving me nuts.

00:47:04.529 --> 00:47:05.249
And in fact.

00:47:06.079 --> 00:47:10.649
Unnecessary new line here
occurs.

00:47:11.609 --> 00:47:16.599
Below popping though I'll
highlight this occurs below and.

00:47:19.019 --> 00:47:20.369
I'll admit it's a Megan epic.

00:47:21.639 --> 00:47:24.418
Making it pick unnecessary new
line here occurs below an

00:47:24.418 --> 00:47:25.589
operator minus mice and.

00:47:26.519 --> 00:47:28.959
OK, very, very necessary going
back.

00:47:29.609 --> 00:47:34.823
This is minus min requires by
range base the post version this

00:47:34.823 --> 00:47:38.879
one OK again no nodiscard const
expert iterator.

00:47:39.599 --> 00:47:41.129
At minus minus int.

00:47:42.029 --> 00:47:45.915
Strengthening noexcept one is no
through complex structural V

00:47:45.915 --> 00:47:49.801
iterator and no except minus
minus drew for this strengthened

00:47:49.801 --> 00:47:53.750
OK bidirectional, Orange base
auto under score capital temp is

00:47:53.750 --> 00:47:54.879
this predict this?

00:47:55.509 --> 00:47:57.229
Return the temp OK.

00:47:59.109 --> 00:48:03.040
Now we're up to plus SQL. Still
no no discard constexpr

00:48:03.040 --> 00:48:07.674
iterator, Ralph Upper SQL Const.
Good difference. Type off. We're

00:48:07.674 --> 00:48:12.167
no, except if this is no, except
inner plus SQL auth. OK, we're

00:48:12.167 --> 00:48:16.380
turning reference that is also
strengthened requires random

00:48:16.380 --> 00:48:20.593
access range based T effects
equivalent to inner plus equal

00:48:20.593 --> 00:48:22.559
auth return to you for this.

00:48:23.279 --> 00:48:26.751
OK, next Council expert iterator
ref. Minus equal const.

00:48:26.751 --> 00:48:30.711
Difference type off. No, except
if no except inner minus SQL off

00:48:30.711 --> 00:48:34.305
strengthened. Still random
access range effects equivalent

00:48:34.305 --> 00:48:38.022
to enter minus SQL auth. Turn
dear for this. OK, I don't see

00:48:38.022 --> 00:48:40.459
any minus or plus getting
swapped here.

00:48:41.089 --> 00:48:44.372
OK, now we're back to the land
of notice car because your

00:48:44.372 --> 00:48:47.882
square bracketing, so notice
card, constexpr, decltype, auto,

00:48:47.882 --> 00:48:51.109
opera square bracket take a
const difference type where.

00:48:51.829 --> 00:48:54.613
Where const. We're
strengthening. No accepted. No

00:48:54.613 --> 00:48:57.788
except stood apply random
access. Closure. Where? In her

00:48:57.788 --> 00:49:01.074
current matching of the body.
Good. Requires random access

00:49:01.074 --> 00:49:01.409
range.

00:49:02.099 --> 00:49:05.561
Affects equivalent to. We've
seen that this random access

00:49:05.561 --> 00:49:06.039
closure.

00:49:06.829 --> 00:49:09.127
Is, I guess, going to be similar
to the dereference closure

00:49:09.127 --> 00:49:11.349
thing. It's going to handle
this, but we'll come back and

00:49:11.349 --> 00:49:13.189
when we find that definition,
we'll look at it.

00:49:14.259 --> 00:49:17.549
OK, then we got equals. So
friend Nodiscard friend.

00:49:18.449 --> 00:49:23.302
Umm constexpr bool operator
equal cons iterator FLHS

00:49:23.302 --> 00:49:24.859
considerato FRHS?

00:49:25.709 --> 00:49:29.377
We are strengthening no
exceptive noexcept le Center is

00:49:29.377 --> 00:49:33.045
our center, OK requires a
quality comparable zip erator

00:49:33.045 --> 00:49:33.439
Const.

00:49:36.079 --> 00:49:36.839
Interesting.

00:49:39.699 --> 00:49:41.069
Aren't we in separator?

00:49:41.749 --> 00:49:43.779
Why are we not using the
injected class name here?

00:49:48.759 --> 00:49:49.739
Ohh no we're.

00:49:50.429 --> 00:49:51.379
Or iterator here.

00:49:53.239 --> 00:49:58.209
Zip Arator is the specific type
dev of which one?

00:50:00.559 --> 00:50:03.816
Oh, no zip Raiders. The template
here. Look, I'm getting

00:50:03.816 --> 00:50:04.559
confused. UM.

00:50:05.639 --> 00:50:08.625
The separators the template here
it says get the iterator from

00:50:08.625 --> 00:50:11.328
the interview ohh the the
original iterator, not the zip

00:50:11.328 --> 00:50:12.229
transform iterator.

00:50:13.259 --> 00:50:13.709
OK.

00:50:17.899 --> 00:50:21.059
OK, so there is no injected
class name, we're the iterator,

00:50:21.059 --> 00:50:24.377
but we got a phrased in terms of
the quality comparable of the

00:50:24.377 --> 00:50:27.642
underlying separator. OK, too
many iterators going back here.

00:50:27.642 --> 00:50:30.697
So matches requires a quality
comparable zipper reader is

00:50:30.697 --> 00:50:33.699
constant. OK, so there's no
concern of an injected class

00:50:33.699 --> 00:50:34.279
name. Good.

00:50:35.639 --> 00:50:39.701
Definition. Yep, X interop
winner. OK, that's good. LHHS is

00:50:39.701 --> 00:50:42.409
equal to Rohs. No swapping or
anything.

00:50:43.719 --> 00:50:47.503
Excuse me, Nodiscard friend
comes expert auto opera

00:50:47.503 --> 00:50:50.779
spaceship considerato FLHS
considerato FRHS.

00:50:51.609 --> 00:50:54.823
No, except if no except
strengthening Lehner spaceship

00:50:54.823 --> 00:50:57.219
Rohner priors. Our anaxes range
based T.

00:50:58.119 --> 00:51:00.612
Turned Ally just in her
spaceship. Archer center. OK,

00:51:00.612 --> 00:51:01.629
good, that's all this.

00:51:02.519 --> 00:51:04.139
And we got some pluses.

00:51:05.189 --> 00:51:07.729
Again returning by value, so no
discard friend.

00:51:08.559 --> 00:51:12.539
Uh constexpr iterator operator.
Plus consider a refl AHS.

00:51:13.309 --> 00:51:17.431
Const difference type RHS Reno
Exceptive no except match the

00:51:17.431 --> 00:51:21.689
body construct iterator brace
from DFL parent LHS enter pasari

00:51:21.689 --> 00:51:25.339
just brace strengthened requires
random access range.

00:51:26.309 --> 00:51:30.873
Return iterator deaf parent I
enter plus N Yep, that's exactly

00:51:30.873 --> 00:51:35.293
right. And the next one is the
same, except things have been

00:51:35.293 --> 00:51:39.279
swapped around. So nodiscard
friend constexpr iterator

00:51:39.279 --> 00:51:43.843
operator plus Const difference
type lehs, const, iterator ref.

00:51:43.843 --> 00:51:48.408
Rohs no except if no except swap
L&amp;R exactly L to RR to LL

00:51:48.408 --> 00:51:52.539
quiz random access range
iterator. This matches OK good.

00:51:54.799 --> 00:51:57.369
That's that's this getting close
to the end of the iterator.

00:51:57.889 --> 00:52:03.180
Umm nodiscard friend constexpr
iterator operator minus cons

00:52:03.180 --> 00:52:07.149
iterator ref LHHS cons
difference type Rohs.

00:52:07.789 --> 00:52:07.979
Yep.

00:52:08.839 --> 00:52:11.423
Noexcept if no except
strengthening iterator deaf

00:52:11.423 --> 00:52:14.732
parent I just enter minus Rohs.
Here I make sure we're not copy

00:52:14.732 --> 00:52:18.143
pasting stuff wrongly requires a
random access range. Yep, that's

00:52:18.143 --> 00:52:18.609
all good.

00:52:20.119 --> 00:52:23.874
OK. And then read something so
horrible clang format needed to

00:52:23.874 --> 00:52:24.709
be suppressed.

00:52:25.759 --> 00:52:27.939
Interesting. I wouldn't expect
this to need it.

00:52:29.009 --> 00:52:31.575
Maybe it really didn't like
this. That's really surprising.

00:52:31.575 --> 00:52:33.929
Usually clang format, it's
pretty good about this now.

00:52:35.819 --> 00:52:37.609
I won't comment. I assume there
was a reason for this.

00:52:38.419 --> 00:52:38.769
OK.

00:52:38.889 --> 00:52:41.499
So notice card friend.

00:52:42.829 --> 00:52:46.656
Constexpr difference type
operator minus. Consider refl us

00:52:46.656 --> 00:52:47.759
consider refr us.

00:52:48.389 --> 00:52:52.574
You accept if noexcept elhs
inner minus Rohner correct order

00:52:52.574 --> 00:52:56.691
strengthened requires so I
Sentinel 4 ZIP reader is con zip

00:52:56.691 --> 00:52:57.789
reader is const.

00:52:59.029 --> 00:53:00.629
OK, does this default?

00:53:02.909 --> 00:53:04.884
Can you provide just one
argument here? And I know it's

00:53:04.884 --> 00:53:06.966
exactly what the standard says.
I thought there was like a

00:53:06.966 --> 00:53:07.249
default.

00:53:08.959 --> 00:53:10.009
Or is it?

00:53:10.489 --> 00:53:11.829
I don't believe so.

00:53:10.959 --> 00:53:14.274
Where is the definition OK?
Maybe I'm maybe I'm

00:53:14.274 --> 00:53:18.695
misremembering. I guess it would
say concept somewhere. Usages.

00:53:15.259 --> 00:53:16.249
Should be an extra utility.

00:53:18.695 --> 00:53:19.939
Yeah, there we go.

00:53:21.459 --> 00:53:22.669
OK, there's no default. It's
just.

00:53:21.899 --> 00:53:22.719
It's an internal.

00:53:23.539 --> 00:53:24.359
Seeing it OK.

00:53:26.539 --> 00:53:29.441
OK, so we got to pass them both
try and clang format L just

00:53:29.441 --> 00:53:32.441
enter minus R Just center. OK,
that's all the operators. Then

00:53:32.441 --> 00:53:33.409
we got some helpers.

00:53:35.179 --> 00:53:36.289
So private helper.

00:53:37.469 --> 00:53:39.808
We've got a dereference closure
and then a random access

00:53:39.808 --> 00:53:41.779
closure. So let's scroll up to
the dereference.

00:53:42.869 --> 00:53:46.303
So notice scared on the helper.
Constexpr auto under score

00:53:46.303 --> 00:53:49.796
chapter dereference closure.
This is excuse me constant and

00:53:49.796 --> 00:53:50.379
no except.

00:53:51.549 --> 00:53:56.056
Why is it no except because
we're simply capturing at this

00:53:56.056 --> 00:54:00.487
pointer? OK, so this says
return. I'm here return capture

00:54:00.487 --> 00:54:00.869
this.

00:54:02.279 --> 00:54:04.569
Take Const auto ref dot iters.

00:54:05.629 --> 00:54:09.098
And have some noexcept stuff
aerodeck type auto the no except

00:54:09.098 --> 00:54:12.232
to say no except if no except
stood invoked your parent

00:54:12.232 --> 00:54:15.199
function do your filters dot so
it matches the body.

00:54:15.969 --> 00:54:19.569
Umm. And then return invoke dear
parent fun.

00:54:20.379 --> 00:54:21.889
Derek fitters dot.

00:54:23.309 --> 00:54:26.621
On intercurrent. OK, so
dereference closures, good

00:54:26.621 --> 00:54:29.739
random access closure is on the
square bracket.

00:54:30.679 --> 00:54:34.070
So notice carcass expert auto
random access closure take a

00:54:34.070 --> 00:54:36.599
const difference type where
Const noexcept.

00:54:37.369 --> 00:54:41.087
OK, we are capturing the this
pointer. We're capturing where

00:54:41.087 --> 00:54:44.806
which is just a different types.
That's fine. It could be no

00:54:44.806 --> 00:54:48.099
except template and unclass this
time iterator types.

00:54:49.019 --> 00:54:53.819
Replacing eyes, pick Const
iterator types ref dot iters.

00:54:54.949 --> 00:54:58.410
So no, except strengthening and
then aerodeck type auto anodes

00:54:58.410 --> 00:55:00.169
horribly wrapped on GitHub here.

00:55:02.029 --> 00:55:04.934
We're no exceptive, no, except
the should match. The body stood

00:55:04.934 --> 00:55:07.430
invoked your current function it
or static cast it are

00:55:07.430 --> 00:55:09.519
difference. Tea if we're OK,
that's all good.

00:55:10.289 --> 00:55:14.309
As this matches dear of parent
fan hitters of.

00:55:15.119 --> 00:55:18.596
OK, uh, Tyler has replaced this
interference paren with the

00:55:18.596 --> 00:55:20.799
static cast. Very much
appreciate it.

00:55:21.959 --> 00:55:25.700
Because we do not like our C
style or functional style C

00:55:25.700 --> 00:55:28.129
semantics casts. OK, that's
perfect.

00:55:29.139 --> 00:55:31.259
OK, that's the end of.

00:55:32.639 --> 00:55:34.289
The iterator OK, the Sentinel.

00:55:36.309 --> 00:55:38.679
OK, we've got a comment here
that.

00:55:39.869 --> 00:55:43.143
Sure looks like it's going to
need to be become a transition.

00:55:43.143 --> 00:55:46.470
So there's a Sentinel. Here's a
Sentinel. Same template stuff.

00:55:46.470 --> 00:55:49.850
Here's a Sentinel. OK, template
bool under score kept is Conn's

00:55:49.850 --> 00:55:53.283
class. under score kept Sentinel
private stuff. Grant friendship

00:55:53.283 --> 00:55:56.241
does it transform. View our
parent. OK, so this comment

00:55:56.241 --> 00:55:59.568
says, so here's an interesting
MSVC bug we'll come eye is bug.

00:55:59.568 --> 00:56:02.684
We usually avoid saying bug in
our product code if we have

00:56:02.684 --> 00:56:05.694
signal operator minus return
range difference team maybe

00:56:05.694 --> 00:56:05.959
cons.

00:56:06.889 --> 00:56:08.439
Iterator const.

00:56:10.269 --> 00:56:11.759
There's iterator comes coming
from.

00:56:12.959 --> 00:56:15.854
Oh, it's it's templated here.
Interview directly as suggested

00:56:15.854 --> 00:56:18.657
in the CPP standard, ADL does
not seem to find the function

00:56:18.657 --> 00:56:21.646
test suite and the program fails
to compile. This does not seem

00:56:21.646 --> 00:56:24.589
to happen with client. OK, this
needs to be reported as a bug.

00:56:26.319 --> 00:56:28.609
This should be reported.

00:56:29.619 --> 00:56:31.839
As an MSVC bug.

00:56:36.279 --> 00:56:38.569
And then this.

00:56:39.039 --> 00:56:45.169
So should be marked as
transition.

00:56:45.929 --> 00:56:50.549
Citing the bug number we
conventionally.

00:56:51.429 --> 00:56:58.439
Uh, avoid a literally saying bug
in the product code.

00:56:59.529 --> 00:57:02.371
I'm trying to think do we
actually have? I'm curious, do

00:57:02.371 --> 00:57:05.563
we actually have any occurrences
where we violated that role at

00:57:05.563 --> 00:57:07.259
least in ink? Do we ever say
bug?

00:57:08.739 --> 00:57:12.916
We do say compiler bug
workaround for the vitar disc

00:57:12.916 --> 00:57:13.389
stuff.

00:57:14.629 --> 00:57:16.489
Which is a little bit more
direct than we usually do.

00:57:18.389 --> 00:57:22.093
That that was my fault too. I
did that, Victor, this stuff,

00:57:22.093 --> 00:57:25.427
this PMD, this would be an
internal interesting. This

00:57:25.427 --> 00:57:29.194
should if it's a bug in invoke.
This should really be an STL

00:57:29.194 --> 00:57:32.899
internal static invoke or sorry
STL internal static assert.

00:57:34.369 --> 00:57:37.248
Yeah, I think that probably
predates the existence of STL

00:57:36.739 --> 00:57:37.509
The probably does.

00:57:37.248 --> 00:57:38.489
internal static is there.

00:57:39.049 --> 00:57:41.979
Yeah, I'll record it too. I'll
clean this up later. Um.

00:57:42.899 --> 00:57:46.397
Should be. We're finding all
these great things to clean up

00:57:46.397 --> 00:57:49.895
internal static cert and then
this is just a comment saying

00:57:49.895 --> 00:57:53.334
this should work. Otherwise
there's a bug. So OK, so we do

00:57:53.334 --> 00:57:54.909
generally avoid saying bug.

00:57:58.539 --> 00:58:00.929
OK, let's see.

00:58:02.709 --> 00:58:05.892
If this works with Clang, what
is actually being worked around

00:58:05.892 --> 00:58:08.419
here? If we have minus return
range difference T?

00:58:09.069 --> 00:58:13.609
OK. So Tyler is introducing an
alias template to avoid

00:58:13.609 --> 00:58:17.159
literally saying range
difference T there.

00:58:18.089 --> 00:58:23.596
So the Sentinel operator minus
for claying could do the right

00:58:23.596 --> 00:58:24.129
thing.

00:58:26.369 --> 00:58:29.279
Is it worth guarding the
workaround with if and deaf?

00:58:30.699 --> 00:58:33.139
Or should we just always use the
workaround?

00:58:35.039 --> 00:58:37.322
If it seems like could be
reasonable always, it's used

00:58:37.322 --> 00:58:39.939
twice. If we guarded both, that
would be annoying. I'm OK with

00:58:39.939 --> 00:58:42.389
always using the workaround
until we got to get rid of it.

00:58:42.989 --> 00:58:43.729
Umm.

00:58:46.089 --> 00:58:46.509
Yeah.

00:58:47.859 --> 00:58:50.344
The little bit annoying when we
have something marked as

00:58:50.344 --> 00:58:52.873
transition without a clear
reminder of what to do when it

00:58:52.873 --> 00:58:53.309
goes away.

00:58:53.879 --> 00:58:56.542
Umm, but I think it would be
fine. We'll we'll be able to

00:58:56.542 --> 00:58:59.298
backtrack and figure out what
happened here. This should be

00:58:59.298 --> 00:59:02.191
reported as an MSVC bug and then
this code should be marked as

00:59:02.191 --> 00:59:04.855
transition citing the bug
number. We conventionally avoid

00:59:04.855 --> 00:59:07.518
literally saying bug in the
product code on actually with

00:59:07.518 --> 00:59:08.529
only a few exceptions.

00:59:15.709 --> 00:59:16.039
OK.

00:59:17.289 --> 00:59:20.537
This is extracted template on
bool, under score kept iterator,

00:59:20.537 --> 00:59:23.373
cons using iterator. Sentinel
difference type is range

00:59:23.373 --> 00:59:26.467
difference, team maybe Const
iterator, Const interview. OK,

00:59:26.467 --> 00:59:29.509
so here's our data Member no
unique address which is maybe

00:59:29.509 --> 00:59:32.500
not super useful when we only
have one day to remember. I

00:59:32.500 --> 00:59:35.800
forget the rules but no unique
address. We got. The Sentinel is

00:59:35.800 --> 00:59:36.419
Const inner.

00:59:38.209 --> 00:59:42.069
And then we are still in the
private section.

00:59:42.999 --> 00:59:45.089
We have a const expert explicit.

00:59:45.909 --> 00:59:47.139
Under score capital Sentinel.

00:59:47.949 --> 00:59:51.280
Construct from a Sentinel is
const under inner honor

00:59:51.280 --> 00:59:54.611
strengthening. We're no
acceptive is no through copy

00:59:54.611 --> 00:59:56.749
constructible. V Sentinels
const.

00:59:57.869 --> 01:00:01.669
Interesting that we don't bother
moving it exposition only.

01:00:02.349 --> 01:00:05.449
Umm, that's what the standard
depicts. So OK.

01:00:06.159 --> 01:00:07.319
Caused the standard holes too.

01:00:08.859 --> 01:00:11.329
Then oops, I lost my place.

01:00:15.729 --> 01:00:18.759
There's a converting constructor
here.

01:00:19.609 --> 01:00:23.127
No, sorry. That's why we just
reviewed losing my place. This

01:00:23.127 --> 01:00:26.818
one here template on Bool, under
score kept iterator cons where

01:00:26.818 --> 01:00:27.799
nodiscard helper.

01:00:28.789 --> 01:00:33.719
We are static, we're constexpr.
We return Const auto ref.

01:00:34.419 --> 01:00:36.849
Or called get iterator zipper
orator.

01:00:37.499 --> 01:00:40.309
We take Const iterator,
iterator, concrete ITER.

01:00:41.699 --> 01:00:44.269
We can't because already static,
but we're no except.

01:00:46.259 --> 01:00:49.549
And we we returned refs. That's
fine. Umm, return. Enter, enter.

01:00:50.219 --> 01:00:51.919
Because we were granted
friendship.

01:00:53.239 --> 01:00:53.919
Is that true?

01:00:54.629 --> 01:00:57.799
We're reaching into the iterator
class.

01:01:01.479 --> 01:01:04.029
And because we are a member of.

01:01:06.149 --> 01:01:09.251
The parents have transform view.
We have the same access rights

01:01:09.251 --> 01:01:11.966
as any other member. The
iterator granted friendship to

01:01:11.966 --> 01:01:15.117
the parent and thus the Sentinel
can access it. OK, that's good.

01:01:15.117 --> 01:01:17.639
So we have the minimum amount of
friendship needed.

01:01:20.019 --> 01:01:24.138
OK, so public matching this
public Sentinel, again, the same

01:01:24.138 --> 01:01:27.852
concern about the No, except
I'll go back and edit the

01:01:27.852 --> 01:01:30.689
comment that it also applies to
Sentinel.

01:01:31.559 --> 01:01:35.245
Rather than having to comments
or is it here? Oh, I didn't have

01:01:35.245 --> 01:01:37.319
this one. I hate it when I do
that.

01:01:38.049 --> 01:01:38.489
OK.

01:01:42.449 --> 01:01:45.589
Occurs below 4 Sentinel.

01:01:49.449 --> 01:01:52.485
OK, while this is cracked,
simply admitting the no access

01:01:52.485 --> 01:01:55.783
specification will be reasonable
occurs below for Sentinel. OK

01:01:55.783 --> 01:01:59.134
now I'm paranoid and I wonder if
I didn't submit anything else.

01:01:59.134 --> 01:02:01.909
Does anything say add review no
perfect OK resuming.

01:02:04.369 --> 01:02:04.639
Here.

01:02:06.799 --> 01:02:10.444
OK, so we are hopefully getting
close to the end of the product

01:02:10.444 --> 01:02:10.729
code.

01:02:12.659 --> 01:02:16.786
Constexpr excuse me, I'm
constexpr sentinal taking a

01:02:16.786 --> 01:02:21.537
Sentinel of not Const. I does
now under score kept archs OK.

01:02:21.537 --> 01:02:26.054
We're strengthened. So no,
except strengthened when is no

01:02:26.054 --> 01:02:30.727
through convertible V zentyal
false to Sentinel. Const very

01:02:30.727 --> 01:02:35.088
much like the Iterator 1
requires Const and convertible

01:02:35.088 --> 01:02:38.749
tools from Sentinel Falls to
Sentinels. Const.

01:02:39.489 --> 01:02:45.596
Uh construct inner withstood
move RHS inner good got all the

01:02:45.596 --> 01:02:47.899
qualification and then?

01:02:50.439 --> 01:02:52.870
OK. Wow, I really wonder how
Clang format is mangling this.

01:02:52.870 --> 01:02:54.329
Maybe it doesn't like the
noexcept?

01:02:55.969 --> 01:03:01.553
Template unbook iterator Const
OK, that's standing in for other

01:03:01.553 --> 01:03:06.788
Const here requires Sentinel
four. Sentinel is const zipper

01:03:06.788 --> 01:03:07.399
orator.

01:03:08.279 --> 01:03:11.581
Other const. OK, let's make sure
we didn't get swapped zenel

01:03:11.581 --> 01:03:14.938
Const is Sentinel is const zip
rate or other Const zip, rater

01:03:14.938 --> 01:03:15.859
iterator cons OK.

01:03:16.619 --> 01:03:20.535
And if Clang format where
Nodiscard friend expert bowl up

01:03:20.535 --> 01:03:24.181
equal counts iterator of
Iterator Const as other cons

01:03:24.181 --> 01:03:24.789
refl AHS.

01:03:25.429 --> 01:03:27.069
Constant nor FRS.

01:03:27.759 --> 01:03:31.174
Or strength that no septic. No.
Except can we say get iterator

01:03:31.174 --> 01:03:32.909
separator lehs is our center OK.

01:03:33.829 --> 01:03:34.509
Uh and?

01:03:34.589 --> 01:03:35.779
And.

01:03:36.759 --> 01:03:38.349
That's this. OK, we need that.

01:03:39.509 --> 01:03:40.559
This helper function.

01:03:41.389 --> 01:03:44.840
Uh, we need the helper function
because this is a friend and we

01:03:44.840 --> 01:03:48.184
haven't granted access to the
friend, so we've got to do this

01:03:48.184 --> 01:03:51.529
like chain of helpers to get to
the guts. OK, so that's good.

01:03:52.229 --> 01:03:55.999
Um, same deal here. In fact, it
should look very similar.

01:03:58.889 --> 01:04:02.422
This is for the minus. Wait,
where are we? We just did the

01:04:02.422 --> 01:04:04.459
equal. Now in one of the
minuses.

01:04:05.109 --> 01:04:05.419
OK.

01:04:06.299 --> 01:04:10.576
So template bool Iterator Const
requires High Sentinel 4 xenel

01:04:10.576 --> 01:04:14.988
is const matching, zenel, Const,
zip, rater iterator Const which

01:04:14.988 --> 01:04:18.519
zip rater other Const notice
card friend Constexpr.

01:04:18.999 --> 01:04:21.539
Uh, here's that work round.

01:04:22.229 --> 01:04:25.121
Iterator Sentinel difference
type iterator constant standing

01:04:25.121 --> 01:04:28.061
in for range difference T. Maybe
consider constant review. OK

01:04:28.061 --> 01:04:28.299
yeah.

01:04:29.049 --> 01:04:34.050
Clang format off operator minus
tank considerate or of iterator

01:04:34.050 --> 01:04:38.894
cons reflexus concentr chess or
strengthened no, except if no

01:04:38.894 --> 01:04:43.661
except same body with the minus
clang format on return. Yep,

01:04:43.661 --> 01:04:44.599
that's this.

01:04:45.329 --> 01:04:48.888
And then we've got it reversed.
OK, so should be exactly the

01:04:48.888 --> 01:04:50.639
same except stuff as reversed.

01:04:51.819 --> 01:04:55.689
Yep, that's good iterator Const
off on.

01:04:56.669 --> 01:05:00.032
Operator minus. OK, so we have
consentual, Raph. That's not

01:05:00.032 --> 01:05:03.451
LHS. Const, iterator, iterator.
Const graph. That's rohs. No

01:05:03.451 --> 01:05:04.629
exceptive. No except.

01:05:05.519 --> 01:05:10.565
LHHS inner minus get iterator,
zip, writer of Rohs and this

01:05:10.565 --> 01:05:11.659
matches good.

01:05:12.759 --> 01:05:14.789
OK. That is the Sentinel.

01:05:15.109 --> 01:05:19.462
Umm, now popping back up to the
transform transform view. So

01:05:19.462 --> 01:05:20.819
we've got all this.

01:05:23.529 --> 01:05:24.659
Yeah, we got the sun all.

01:05:26.419 --> 01:05:29.709
We've got this for sure. Uh, all
the iterators stuff.

01:05:31.219 --> 01:05:36.384
OK. And uh, yeah, these were all
the declarations of the stuff we

01:05:36.384 --> 01:05:37.089
reviewed.

01:05:38.529 --> 01:05:39.579
In the iterator.

01:05:42.719 --> 01:05:43.599
Can we get these?

01:05:48.089 --> 01:05:50.500
Sorry, my brain is wondering if
we got those pluses. I don't

01:05:50.500 --> 01:05:52.279
remember the pluses. If I
already forgotten.

01:05:54.079 --> 01:05:56.261
Yeah, we we got them all. We
have the plus, we got the plus

01:05:56.261 --> 01:05:58.589
all the we got the minus. OK, I
totally. I totally forgot that.

01:06:01.209 --> 01:06:03.619
Yep, all these friends. Yep,
looks good.

01:06:04.909 --> 01:06:07.369
OK, so we're here.

01:06:08.349 --> 01:06:10.669
At the end of the Sentinel
looking at.

01:06:11.449 --> 01:06:12.379
Is a no except.

01:06:13.479 --> 01:06:16.519
And we have that probably
because it's used for

01:06:16.519 --> 01:06:17.659
strengthening, OK.

01:06:20.029 --> 01:06:23.061
And so this is actually a
variable template, so that's

01:06:23.061 --> 01:06:26.313
nice expressed as a Lambda
template bool. under score kept

01:06:26.313 --> 01:06:29.621
is Const, static constexpr bool,
under score kept is and no

01:06:29.621 --> 01:06:30.669
except is a Lambda.

01:06:31.489 --> 01:06:33.159
That is itself noexcept.

01:06:34.079 --> 01:06:34.899
Which I think we.

01:06:35.849 --> 01:06:39.685
Do no, no, we don't need. We
don't technically need it here.

01:06:39.685 --> 01:06:42.139
But again, it's fine if
constexpr per.

01:06:43.189 --> 01:06:46.903
OK. That's interesting. We
should look at the definition of

01:06:46.903 --> 01:06:50.369
end. That's this. Sorry for
screwing around so fast and

01:06:50.369 --> 01:06:50.679
here.

01:06:51.409 --> 01:06:53.649
Umm so if constexpr.

01:06:54.369 --> 01:06:58.104
We want to know common range of
interview which is maybe

01:06:58.104 --> 01:06:59.809
conscious Const interview.

01:07:00.669 --> 01:07:03.879
Then return noexcept. Can we
make an iterator?

01:07:04.729 --> 01:07:05.809
Is const.

01:07:06.919 --> 01:07:09.676
OK, so this is handling both
simultaneously. That's

01:07:09.676 --> 01:07:11.109
interesting. This and this.

01:07:13.039 --> 01:07:14.069
And we're saying.

01:07:17.359 --> 01:07:21.613
OK, so that's so I'm backing up
template is Const. Is then

01:07:21.613 --> 01:07:25.219
noexcept Lambda if constexpr. OK
so common range.

01:07:26.349 --> 01:07:29.615
Of either interview or constant
interview, and that's handled by

01:07:29.615 --> 01:07:32.329
maybe constant is const
interview OK then return. No.

01:07:32.329 --> 01:07:35.495
Except can we make an iterator
false or true? That is iterator

01:07:35.495 --> 01:07:38.059
is const from this and zip and
that's the same so.

01:07:38.749 --> 01:07:43.023
The this drew for this is stood
decal Val of maybe Cons is Khan

01:07:43.023 --> 01:07:44.559
zip transform view ref.

01:07:45.269 --> 01:07:48.444
OK, it's got to be a null value
and then zip end is stood

01:07:48.444 --> 01:07:50.689
equivale. Maybe Constance
interview RAF.

01:07:52.679 --> 01:07:53.339
.net.

01:07:54.309 --> 01:07:54.569
OK.

01:07:55.349 --> 01:07:57.569
Otherwise, we're not coming
range.

01:07:58.919 --> 01:08:01.069
So that's these two.

01:08:01.959 --> 01:08:02.709
Return.

01:08:03.489 --> 01:08:07.552
And if concepts were else OK,
return noexcept of you can make

01:08:07.552 --> 01:08:11.484
a Sentinel of false or true.
That's his const from zip end.

01:08:11.484 --> 01:08:15.089
That's decadal maybe consist
const interview ref. Yep.

01:08:16.129 --> 01:08:19.055
So a little bit of duplication
here. Maybe this could be

01:08:19.055 --> 01:08:20.699
extracted out, but this is fine.

01:08:22.929 --> 01:08:25.920
Yeah, well, my heuristic is
something's repeated three

01:08:25.920 --> 01:08:29.239
times. This should probably be
extracted, but twice is fine.

01:08:30.199 --> 01:08:33.337
OK, so that handles the noexcept
for end and then static

01:08:33.337 --> 01:08:36.531
constexpr bool which is not
templated at all. under score

01:08:36.531 --> 01:08:38.459
capital enable Const begin end
is.

01:08:42.219 --> 01:08:47.300
Looks like the this. Yeah, this
is. This is exactly matching. So

01:08:47.300 --> 01:08:52.069
if we have a range of constant
or view and regular invocable

01:08:52.069 --> 01:08:56.916
Const FFRF range reference T
Const view types dot then we can

01:08:56.916 --> 01:08:58.949
enable Const begin it. OK.

01:09:00.389 --> 01:09:03.273
OK, so we've got the iterator.
We got the Sentinel. We are now

01:09:03.273 --> 01:09:05.929
doing public stuff. Uh, zip,
transform, view, print, run.

01:09:06.919 --> 01:09:10.399
Again, we've got a default here
that has an explicit noexcept.

01:09:11.829 --> 01:09:14.769
This is just saying movable box
and interview I I'm gonna extend

01:09:14.769 --> 01:09:17.439
the comment cause I think that
should be applied here too.

01:09:18.439 --> 01:09:20.869
That's got a. Here we go.

01:09:21.799 --> 01:09:24.749
Chris Bluffer signal and the
transform view.

01:09:26.049 --> 01:09:27.779
But no excessive vestigation.

01:09:29.139 --> 01:09:29.369
OK.

01:09:38.089 --> 01:09:39.959
I sat long. We looked at this.

01:09:40.109 --> 01:09:43.609
Ah, the transform view. OK
defaulted.

01:09:44.649 --> 01:09:45.259
Defaulted.

01:09:46.709 --> 01:09:47.019
OK.

01:09:48.539 --> 01:09:52.517
We're at a constructor. Uh,
constexpr, explicit, zip

01:09:52.517 --> 01:09:57.247
transform view construct from F
fun that's funk under function

01:09:57.247 --> 01:09:58.899
under views dot views.

01:09:59.589 --> 01:10:01.669
View types dot views.

01:10:02.769 --> 01:10:04.519
OK, does this shadow anything?

01:10:05.369 --> 01:10:06.829
I thought we had to view
somewhere.

01:10:08.169 --> 01:10:10.229
Scroll way way way up.

01:10:11.639 --> 01:10:12.589
That's the iterator.

01:10:16.909 --> 01:10:18.659
OK, we only have function in
zip.

01:10:19.759 --> 01:10:23.590
It was the zip view that had the
views. Yeah. So we only have

01:10:23.590 --> 01:10:27.669
function in zip, so no ambiguity
here. We're good. OK, down down.

01:10:27.749 --> 01:10:30.869
Down to Nope, not far enough.
Here we go.

01:10:31.559 --> 01:10:33.909
Umm view types views OK.

01:10:36.519 --> 01:10:39.229
Uh, strengthening. We're no
except if.

01:10:40.699 --> 01:10:41.369
We need.

01:10:44.129 --> 01:10:47.824
Constructing the function with
an in place so is no throw move

01:10:47.824 --> 01:10:49.819
constructible V movable box
funk.

01:10:52.929 --> 01:10:56.778
This is asking is the entire
movable box move constructible,

01:10:56.778 --> 01:11:00.249
but we're constructing one of
them from move function.

01:11:01.459 --> 01:11:03.854
Is this necessary? Could we
simply say is no term move

01:11:03.854 --> 01:11:04.769
constructible V funk?

01:11:07.379 --> 01:11:08.689
I gotta look at what the types
are.

01:11:11.459 --> 01:11:12.469
That's the iterator.

01:11:14.639 --> 01:11:16.909
Function is a movable box of
funk.

01:11:18.059 --> 01:11:18.419
OK.

01:11:20.059 --> 01:11:22.149
I think I'm gonna need to look
at the definition.

01:11:23.239 --> 01:11:26.197
I wouldn't be concerned if this
matched what we're doing, what

01:11:26.197 --> 01:11:28.873
we're calling the in place
constructor of of the movable

01:11:28.873 --> 01:11:29.249
box. So.

01:11:29.909 --> 01:11:34.209
Let's go look at what the move
blocks does. Move a bowl box.

01:11:34.939 --> 01:11:35.369
We're go.

01:11:36.289 --> 01:11:39.967
Simplified optional. So if you
are a in place constructor from

01:11:39.967 --> 01:11:43.119
a bunch of types, we're
strengthened to be is nothrow

01:11:43.119 --> 01:11:46.856
constructible on that type from
types, because we're just going

01:11:46.856 --> 01:11:48.199
to construct the thing.

01:11:49.149 --> 01:11:50.579
If you try to move it.

01:11:51.949 --> 01:11:53.379
Uh, do we have that
strengthened?

01:11:54.919 --> 01:11:57.544
We ask it if it's trivially
moved. Ohh, we ask if it's

01:11:57.544 --> 01:11:58.929
trivially move constructible.

01:12:00.229 --> 01:12:02.639
That's a different question than
an initial construction.

01:12:04.889 --> 01:12:06.259
Oh, no, sorry, this is
overloaded.

01:12:07.499 --> 01:12:11.547
Oh oh, it's not no, except if
it's nontrivial. We always do

01:12:11.547 --> 01:12:13.909
work and we don't strengthen
this.

01:12:17.599 --> 01:12:21.333
It's interesting that this was
not strengthened. OK, so I think

01:12:21.333 --> 01:12:24.950
I think I've actually found a a
minor bug in the the noexcept

01:12:24.950 --> 01:12:26.059
strengthening here.

01:12:26.779 --> 01:12:30.762
Because asking is the movable
that is the movable box no to

01:12:30.762 --> 01:12:32.289
our move constructible.

01:12:33.369 --> 01:12:37.352
We'll say true if it's trivially
move constructible, but straight

01:12:37.352 --> 01:12:40.973
up false if it's not trivially
moved constructible, even if

01:12:40.973 --> 01:12:41.879
it's no except.

01:12:43.889 --> 01:12:47.679
And we're not actually moving
the thing at all here, OK, so.

01:12:48.729 --> 01:12:52.877
This is boats. Minor bogus like
2 out of 10 bogus. Where was I

01:12:52.877 --> 01:12:54.919
looking? I was looking at this.

01:12:56.389 --> 01:12:59.699
We're in ranges, movable box, OK
time to quote.

01:13:03.079 --> 01:13:04.949
STL Inc.

01:13:06.339 --> 01:13:07.269
Ranges.

01:13:10.229 --> 01:13:13.046
The biggest challenge I would
say one of the biggest

01:13:13.046 --> 01:13:16.235
challenges in Marian code is
sitting through, you know, 400

01:13:16.235 --> 01:13:19.371
lines of incredibly repetitive
and every character counts,

01:13:19.371 --> 01:13:22.667
review and then keeping enough
attention so that you actually

01:13:22.667 --> 01:13:26.069
notice the one bit always near
the end, usually where something

01:13:26.069 --> 01:13:29.259
is a little bit questionable.
OK, where's that movable box?

01:13:30.689 --> 01:13:34.196
There are other skills needed,
but this is an underappreciated

01:13:34.196 --> 01:13:37.259
one I think. OK, hit why to get
permalink movable box.

01:13:38.679 --> 01:13:40.559
I'll probably wanna quote both.

01:13:41.409 --> 01:13:44.955
Yeah. So let me duplicate the
first one or the one of them.

01:13:44.955 --> 01:13:48.442
I'm gonna want to quote is this
because this is what we're

01:13:48.442 --> 01:13:49.329
actually doing.

01:13:50.359 --> 01:13:55.009
And then then oops, movable box.

01:13:55.799 --> 01:14:00.839
Come on. Here. Got. Here we go.
It's the move. See door.

01:14:01.749 --> 01:14:03.499
That's this thing.

01:14:05.519 --> 01:14:09.318
I'll drop the clay from it off,
move seed, or is trivially

01:14:09.318 --> 01:14:10.349
nontrivial here.

01:14:11.039 --> 01:14:13.129
OK, so this.

01:14:14.369 --> 01:14:17.860
OK, going back to zip transform
view, here we go. So this is

01:14:17.860 --> 01:14:20.779
constructing function from in
place move function.

01:14:22.529 --> 01:14:24.884
This one I think is fine. The
the zip part because that's

01:14:24.884 --> 01:14:25.169
saying.

01:14:25.929 --> 01:14:29.434
I want to make sure if I come in
about a bug in one member that

01:14:29.434 --> 01:14:32.557
I'm not missing another bug
lurking in the second member

01:14:32.557 --> 01:14:36.008
construct. The zip so is no hero
constructible. The interview?

01:14:36.008 --> 01:14:39.240
That's the zip from Studmire
views. That is, take the view

01:14:39.240 --> 01:14:39.569
types.

01:14:40.489 --> 01:14:45.117
Remove reference key from them
and then add ref ref OK that's

01:14:45.117 --> 01:14:49.895
right. So it's this part that is
not right. OK, I wanna comment

01:14:49.895 --> 01:14:50.119
on.

01:14:51.689 --> 01:14:54.914
Maybe just this now I wanna get
that. No, except in there.

01:14:54.914 --> 01:14:56.609
Otherwise it'll look weird. OK.

01:14:58.829 --> 01:15:01.369
Ah, I specifically think this is
wrong.

01:15:03.689 --> 01:15:04.849
This says.

01:15:05.739 --> 01:15:12.725
In the stirring, thinned new
accept specification, but we

01:15:12.725 --> 01:15:13.569
aren't.

01:15:14.889 --> 01:15:18.779
Move constructing a.

01:15:20.329 --> 01:15:21.919
Movable box.

01:15:23.249 --> 01:15:23.689
Here.

01:15:24.459 --> 01:15:25.359
Instead.

01:15:26.409 --> 01:15:28.599
Where using its.

01:15:29.459 --> 01:15:29.909
In.

01:15:30.689 --> 01:15:31.889
Place.

01:15:32.809 --> 01:15:33.799
Constructor.

01:15:35.179 --> 01:15:37.444
Are actually want this one
quoted, I'll quote them in

01:15:37.444 --> 01:15:39.459
order. Oh, I think that was the
one that I had.

01:15:40.079 --> 01:15:40.679
Umm.

01:15:41.629 --> 01:15:45.539
Which directly constructs the
stored type. I'll say that.

01:15:47.859 --> 01:15:48.279
Which?

01:15:49.329 --> 01:15:53.359
Directly directory directly
constructs.

01:15:55.849 --> 01:15:58.129
Be stored type.

01:15:59.399 --> 01:16:00.469
And.

01:16:01.899 --> 01:16:04.019
Is accordingly.

01:16:04.889 --> 01:16:06.839
Strengthened.

01:16:09.239 --> 01:16:11.689
Umm, I think.

01:16:12.529 --> 01:16:13.639
It would.

01:16:18.049 --> 01:16:22.784
Miller, both both options then
mention which one I prefer. I

01:16:22.784 --> 01:16:23.639
either the.

01:16:26.989 --> 01:16:35.249
Exception specification here
should exactly match the.

01:16:36.019 --> 01:16:36.669
Mem.

01:16:37.689 --> 01:16:41.149
Initializer list by saying.

01:16:41.989 --> 01:16:44.279
Is it's actually just this.

01:16:45.249 --> 01:16:47.879
Uh, double checking before I
copy paste is no through

01:16:47.879 --> 01:16:48.659
constructible V.

01:16:50.189 --> 01:16:54.199
From and then make sure we copy
the right one movable box funk.

01:16:55.989 --> 01:16:58.479
From and then when we move
function.

01:17:00.119 --> 01:17:01.289
That would be.

01:17:02.329 --> 01:17:05.312
Funk is an object type, right?
And I hope it's not a reference

01:17:05.312 --> 01:17:05.549
type.

01:17:06.299 --> 01:17:08.539
I think we can just say funk
here.

01:17:10.109 --> 01:17:11.569
Do we have any constraints on
this thing?

01:17:13.019 --> 01:17:13.979
Sorry for scrolling.

01:17:15.239 --> 01:17:17.269
Ohh template move constructible
funk.

01:17:18.099 --> 01:17:20.702
I forget if that. Oh, no, here
we go. Is object VC fund. So

01:17:20.702 --> 01:17:23.219
it's an object type. There's no
sneaky references. Great.

01:17:25.129 --> 01:17:26.019
Because if I say.

01:17:26.899 --> 01:17:29.885
Funk. And if it could be a
reference that has interesting

01:17:29.885 --> 01:17:33.076
effects for type traits, but if
lunch is an guaranteed object

01:17:33.076 --> 01:17:36.268
type then just saying funk means
that it's an R value. Boy, I

01:17:36.268 --> 01:17:37.659
wanna make this bigger, OK.

01:17:38.199 --> 01:17:43.319
Ah, there we go. So is no throw
constructible V the thing we're

01:17:43.319 --> 01:17:46.599
constructing is the function.
That is a.

01:17:47.599 --> 01:17:51.137
That confusingly, actually
function is a movable box, but

01:17:51.137 --> 01:17:53.029
under function under is a funk.

01:17:53.949 --> 01:17:56.289
It's not wrong I think.

01:18:00.269 --> 01:18:03.773
Yeah, correct. Move a box funk
function. OK, so the types are

01:18:03.773 --> 01:18:07.221
different even though they only
different under score. Going

01:18:07.221 --> 01:18:10.839
back down is another constructiv
movable box to funk from funk.

01:18:12.579 --> 01:18:13.019
That.

01:18:13.859 --> 01:18:14.299
Umm.

01:18:15.969 --> 01:18:19.199
Or it should?

01:18:23.799 --> 01:18:25.229
Take a shortcut.

01:18:25.919 --> 01:18:27.309
And.

01:18:31.419 --> 01:18:32.749
Match or say.

01:18:34.759 --> 01:18:40.091
Shortcut and depict the ultimate
construction, the ultimate

01:18:40.091 --> 01:18:42.669
construction being performed.

01:18:43.649 --> 01:18:47.229
And that is, that's just a move
construction of the object type

01:18:47.229 --> 01:18:49.299
is no throw move constructible
funk.

01:18:50.199 --> 01:18:53.829
So that would be this, which was
in Ridgely intended.

01:18:54.549 --> 01:18:55.579
Of the funk.

01:18:57.709 --> 01:18:58.749
OK. Is that right?

01:18:59.769 --> 01:19:02.599
I'll, I'll provide it. All is
not move start funk.

01:19:04.599 --> 01:19:05.749
I prefer this.

01:19:10.389 --> 01:19:13.147
And then I'll mention that this
is actually correctness such

01:19:13.147 --> 01:19:13.419
issue.

01:19:15.419 --> 01:19:18.339
This is actually a minor.

01:19:19.239 --> 01:19:20.549
Correctness issue.

01:19:22.499 --> 01:19:22.809
Are.

01:19:24.299 --> 01:19:27.479
This is actually, I'll just say
minor issue.

01:19:28.859 --> 01:19:34.599
Not purely cosmetic as movable.

01:19:35.229 --> 01:19:39.679
Boxes move constructor is not.

01:19:40.579 --> 01:19:45.969
Always strengthened according to
what it does.

01:19:47.359 --> 01:19:50.225
OK, complicated comment. Let's
make sure I didn't script

01:19:50.225 --> 01:19:50.929
anything here.

01:19:51.609 --> 01:19:52.819
Uh, OK, so.

01:19:53.549 --> 01:19:57.379
This says and checking this one.

01:19:58.779 --> 01:20:02.557
Is no through move constructible
V movable box funk in the

01:20:02.557 --> 01:20:05.695
strengthen Noexcept
specification, but we aren't

01:20:05.695 --> 01:20:08.129
move constructing a movable box
here.

01:20:08.959 --> 01:20:12.024
Move constructible with
constructing with box. Yes.

01:20:12.024 --> 01:20:15.560
Instead we're using its in place
constructor which directly

01:20:15.560 --> 01:20:19.450
constructs the store type and is
accordingly strengthened quoting

01:20:19.450 --> 01:20:22.574
movable box and place T
constructor strengthened OK,

01:20:22.574 --> 01:20:25.344
either the exception
specification here should

01:20:25.344 --> 01:20:27.349
exactly match the list by
saying.

01:20:28.299 --> 01:20:32.609
Is no through Constructable V
our movable box funk.

01:20:33.229 --> 01:20:35.069
From the funk R value.

01:20:37.769 --> 01:20:40.949
Actually, that doesn't even
exactly match. Whoo, yeah,

01:20:40.949 --> 01:20:44.244
really doesn't know I screwed
that up. It's really is no

01:20:44.244 --> 01:20:47.945
structural be moving box funk.
And then the in place thing. And

01:20:47.945 --> 01:20:51.703
then this, I guess we would need
to stay in place. T technically

01:20:51.703 --> 01:20:55.288
this is an lvalue, but we can
kind of take a shortcut and say

01:20:55.288 --> 01:20:56.329
in place TR value.

01:20:58.989 --> 01:21:01.321
I'll simplify this. I'll I'll
make it, say, depict the

01:21:01.321 --> 01:21:03.823
ultimate construction. This is
actually a minor issue, not

01:21:03.823 --> 01:21:06.326
purely cosmetic. Is movable
walks, is move. Constructor is

01:21:06.326 --> 01:21:08.489
not always strengthened
according to what it does.

01:21:10.329 --> 01:21:12.652
Here's the move constructors.
This one is clearly not

01:21:12.652 --> 01:21:15.319
strengthened. OK, so let's go
fix this bit about the ultimate

01:21:15.319 --> 01:21:15.879
construction.

01:21:16.659 --> 01:21:17.409
Umm.

01:21:21.359 --> 01:21:27.920
Which would be somewhat annoying
as we'd need to mention the

01:21:27.920 --> 01:21:30.609
thing in place T as well.

01:21:36.519 --> 01:21:39.078
OK, let's just gloss over the
annoying thing that I don't

01:21:39.078 --> 01:21:41.505
actually want to suggest here.
Go either the accession

01:21:41.505 --> 01:21:43.977
specification here should
exactly match the initializer

01:21:43.977 --> 01:21:46.669
list, which would be somewhat
annoying as we need to mention

01:21:46.669 --> 01:21:49.449
in place T2 or it should take a
shortcut and pick the ultimate

01:21:49.449 --> 01:21:50.729
construction being performed.

01:21:51.639 --> 01:21:55.713
Is no throw move constructible V
funk, because we're ultimately

01:21:55.713 --> 01:21:59.469
moving the function which is
funk. I prefer this. OK good.

01:22:01.029 --> 01:22:05.031
OK, getting close to the end. We
made the comment on the zip

01:22:05.031 --> 01:22:09.231
transform view constructor. Then
we got some beginning size and

01:22:09.231 --> 01:22:11.069
maybe a deduction guide. OK.

01:22:13.939 --> 01:22:18.026
OK. And this is fairly simple
because stuff has already been

01:22:18.026 --> 01:22:21.109
lifted out. We have got missing
notice cards.

01:22:23.379 --> 01:22:26.939
All they should be notice, card
begin and size.

01:22:28.379 --> 01:22:28.709
Yeah.

01:22:29.369 --> 01:22:30.209
Begin outsize.

01:22:34.539 --> 01:22:37.809
All of the overloads of begin.

01:22:38.909 --> 01:22:39.629
And.

01:22:40.719 --> 01:22:41.779
And size.

01:22:42.459 --> 01:22:45.719
Should be marked no discard.

01:22:48.229 --> 01:22:51.692
All the overloads of begin and
inside should be marked notice

01:22:51.692 --> 01:22:52.139
card OK.

01:22:53.799 --> 01:22:58.202
O missing notice card constexpr
auto begin strengthening. We are

01:22:58.202 --> 01:22:59.829
no exceptive. No except.

01:23:01.019 --> 01:23:03.954
Matching the body construct
iterator falls from deer for

01:23:03.954 --> 01:23:07.096
this zip. Again, strengthened
return iterator false dear. If

01:23:07.096 --> 01:23:07.869
this tip again.

01:23:09.489 --> 01:23:13.032
And constexpr emitting those car
because we already commented it

01:23:13.032 --> 01:23:16.030
constexpr auto begin Const
strengthening. No except no

01:23:16.030 --> 01:23:19.410
except could read or true dear
if this zip again strengthened

01:23:19.410 --> 01:23:22.409
requires enable costs begin end
because it's the same.

01:23:23.159 --> 01:23:25.559
Return iterator true. Do you
have this again perfect.

01:23:26.439 --> 01:23:28.229
Uh context. Perado end.

01:23:29.119 --> 01:23:32.839
Noexcept, when is and noexcept
false because we're not the

01:23:32.839 --> 01:23:34.479
constant one strengthened.

01:23:35.729 --> 01:23:39.486
If Constexpr commentary
interview return iterator false

01:23:39.486 --> 01:23:43.379
deaf this end. Otherwise return
Sentinel false to depend.

01:23:44.189 --> 01:23:44.569
Cam.

01:23:45.469 --> 01:23:48.019
And then Cortex Broudo end, we
are const.

01:23:48.689 --> 01:23:52.461
No, except when IS and noexcept
true strengthened OK acquires

01:23:52.461 --> 01:23:56.052
naval const, begin, end nothing.
If constexpr common range

01:23:56.052 --> 01:23:59.824
constant review return iterator
true. Do you have this spend?

01:23:59.824 --> 01:24:02.259
Otherwise return Sentinel true
zip end.

01:24:03.039 --> 01:24:03.289
Cat.

01:24:04.909 --> 01:24:06.489
It's esperado size.

01:24:07.629 --> 01:24:11.150
And then strengthen, no, except
if no. Except we can say zip

01:24:11.150 --> 01:24:11.439
size.

01:24:12.349 --> 01:24:16.199
OK, strengthened require size
range interview returns of size.

01:24:18.299 --> 01:24:19.739
Sex burrito size.

01:24:20.549 --> 01:24:21.669
We are const.

01:24:22.369 --> 01:24:27.237
Noexcept if no except zip size
OK still strengthened. Require

01:24:27.237 --> 01:24:32.105
size range of Const interview
returns zip size OK and a class

01:24:32.105 --> 01:24:32.969
definition.

01:24:33.889 --> 01:24:34.899
Uh deduction guide.

01:24:35.579 --> 01:24:38.549
Template on class F which is the
funk.

01:24:39.329 --> 01:24:45.667
Class dot ranges is it transform
view from function ranges ref to

01:24:45.667 --> 01:24:51.429
do zip transform view of funk
and views. Alt ranges dot OK.

01:24:52.469 --> 01:24:54.993
Uh, yeah, that's the
constructor. Yep, we saw that.

01:24:54.993 --> 01:24:57.712
Now, is it transform fund? This
is all specified by the

01:24:57.712 --> 01:25:00.722
expression of equivalent stuff
in the standard, so that's why

01:25:00.722 --> 01:25:01.839
it doesn't appear here.

01:25:02.919 --> 01:25:05.690
There's nothing else missing
here. OK, so I think I can

01:25:05.690 --> 01:25:06.829
actually minimize this.

01:25:08.209 --> 01:25:09.239
The last bit.

01:25:09.959 --> 01:25:11.289
Why are we going public again?

01:25:15.549 --> 01:25:19.513
Ohh I lost my place. We closed
up transform view deduction

01:25:19.513 --> 01:25:23.679
guide. Opening up views now we
have this transform struct so.

01:25:24.759 --> 01:25:29.106
Struct under score capital ZIP
transform fund, private stuff,

01:25:29.106 --> 01:25:30.579
public stuff. OK, so.

01:25:31.239 --> 01:25:32.929
Here we have a static constexpr
bool.

01:25:33.919 --> 01:25:36.446
Template on class under score
kept a fun class. dot under

01:25:36.446 --> 01:25:39.016
score kept types starter,
classroom bool, under score kept

01:25:39.016 --> 01:25:40.019
is invocation noexcept.

01:25:40.739 --> 01:25:45.735
Uh, we're Lambda, we're mark.
No, except if constexpr size of

01:25:45.735 --> 01:25:48.959
dot our types is zero, we have
nothing.

01:25:49.899 --> 01:25:51.199
This says equivalent to.

01:25:51.919 --> 01:25:55.749
Using decayed funk is decayed T
funk return.

01:25:59.639 --> 01:26:02.428
Wow. What? What? What? Even is
the syntax? My brain is refusing

01:26:02.428 --> 01:26:03.039
to parse this.

01:26:04.929 --> 01:26:06.059
Return.

01:26:06.749 --> 01:26:08.269
OK, there's too many parentheses
here.

01:26:09.129 --> 01:26:09.639
One moment.

01:26:12.289 --> 01:26:15.639
OK, then I I can't even realize
parenthesis.

01:26:16.579 --> 01:26:19.809
OK, so tell this that this is
C++ KMC.

01:26:19.889 --> 01:26:23.395
As pass some nice parenthesis
highlighting. OK, so we've got

01:26:23.395 --> 01:26:27.017
some why are there? There's a
comma operator in here. OK, this

01:26:27.017 --> 01:26:30.753
start to look better. What does
this auto? This is that language

01:26:30.753 --> 01:26:34.030
feature that Tyler called out.
That's why my brain can't

01:26:34.030 --> 01:26:37.191
process it cuz it's future
technology. My brain is not

01:26:37.191 --> 01:26:37.939
upgraded yet.

01:26:40.739 --> 01:26:43.789
OK, so returned no except of
this expression.

01:26:44.729 --> 01:26:45.759
We have.

01:26:47.319 --> 01:26:48.659
A comma operator.

01:26:50.409 --> 01:26:52.539
Hence this extra layer of
parentheses.

01:26:53.359 --> 01:26:56.803
We are avoiding hijacking by
void casting. Interestingly, the

01:26:56.803 --> 01:27:00.248
first one is being void cast
even though conventionally we do

01:27:00.248 --> 01:27:02.749
the 2nd. But this is just a
comment so fine.

01:27:05.839 --> 01:27:08.009
Why are we checking the decal
VALIS? No, except.

01:27:06.259 --> 01:27:07.119
But then why do we?

01:27:08.849 --> 01:27:12.185
Yeah, that doesn't make any
sense. We can always do this and

01:27:12.185 --> 01:27:12.459
then.

01:27:13.349 --> 01:27:15.309
What is the invoke result T?

01:27:16.019 --> 01:27:20.005
Decay that type. I don't know
what empty does and then is that

01:27:20.005 --> 01:27:23.991
of view. And then can we copy
that? But I don't know what this

01:27:23.991 --> 01:27:26.459
is doing. What is the standard
he say?

01:27:27.139 --> 01:27:31.005
OK, clearly we're saving the the
hardest question for last here.

01:27:31.005 --> 01:27:34.099
Oh, that's up here. OK, I guess
back to split view.

01:27:35.109 --> 01:27:37.319
Oregon draft OK?

01:27:38.689 --> 01:27:40.869
I've used the transform. That's
this thing.

01:27:42.169 --> 01:27:45.379
Oh yeah, OK, so this is what I
was trying to be.

01:27:47.699 --> 01:27:51.712
Copied here that the no except
of the whole expression is

01:27:51.712 --> 01:27:54.549
expression equivalent to
whatever F was.

01:27:55.429 --> 01:27:58.013
But that's kind of weird because
once you give it to zip

01:27:58.013 --> 01:28:00.869
transform like it's there like,
who cares whether true or not.

01:28:01.799 --> 01:28:05.684
I I guess it I guess expression
expression equivalent has to

01:28:03.639 --> 01:28:05.349
Ah there.

01:28:05.684 --> 01:28:06.449
handle that.

01:28:06.979 --> 01:28:09.970
Expression equivalent means that
if you're evaluate F, it has to

01:28:07.629 --> 01:28:08.209
But we don't.

01:28:09.970 --> 01:28:11.949
be evaluated in the equivalent
expression.

01:28:12.599 --> 01:28:15.070
Since there's no way to avoid
that right for an

01:28:15.070 --> 01:28:18.315
implementation, we can't make
that expression disappear in the

01:28:18.315 --> 01:28:19.139
library somehow.

01:28:18.509 --> 01:28:18.959
Right.

01:28:20.279 --> 01:28:21.429
But that said that.

01:28:20.479 --> 01:28:21.469
But in the.

01:28:22.229 --> 01:28:26.979
Doesn't need to be reflected in
implementation code. That's

01:28:25.949 --> 01:28:27.529
And then yeah, in the no except.

01:28:26.979 --> 01:28:27.929
super weird.

01:28:28.789 --> 01:28:30.519
OK, so this should probably go
away.

01:28:32.619 --> 01:28:34.249
And.

01:28:37.069 --> 01:28:40.184
Well, we'll see about the actual
code here, but yeah, this is

01:28:40.184 --> 01:28:43.300
super weird. Do we even like the
things? Do we even need this

01:28:43.300 --> 01:28:46.115
comment? Like, I know Tyler is
trying to explain, and I

01:28:46.115 --> 01:28:46.819
appreciate it.

01:28:48.479 --> 01:28:49.759
Yeah, I don't like the comment
at all.

01:28:48.559 --> 01:28:51.894
That there's a transformation
happening I I think I think

01:28:51.894 --> 01:28:52.699
merely citing.

01:28:53.159 --> 01:28:56.177
Umm, the standards that it's
implementing would be

01:28:56.177 --> 01:28:56.829
sufficient.

01:28:57.929 --> 01:29:01.301
Rather than trying to explain
what we're trying to explain,

01:29:01.301 --> 01:29:04.280
what it's doing when studying
the standard should be

01:29:04.280 --> 01:29:04.899
sufficient.

01:29:05.739 --> 01:29:07.629
OK, let's ask for removal of the
comment.

01:29:10.649 --> 01:29:12.399
OK, let's see.

01:29:17.259 --> 01:29:17.769
Hi.

01:29:18.629 --> 01:29:23.424
Thanks for including a yeah, I
don't know. It's not freeze like

01:29:23.424 --> 01:29:23.799
that.

01:29:28.909 --> 01:29:31.659
I'll I'll blame Casey, Casey and
IUM.

01:29:32.459 --> 01:29:36.519
I think that it would be simpler
to.

01:29:35.699 --> 01:29:36.519
That's what I'm here for.

01:29:36.599 --> 01:29:39.989
You to.

01:29:39.179 --> 01:29:39.929
Leave me.

01:29:41.409 --> 01:29:43.858
It's all Casey. Well, it's it's
ranges. So ultimately it is all

01:29:43.858 --> 01:29:44.279
your fault.

01:29:46.369 --> 01:29:51.016
Because you started it or you
were critically involved in the

01:29:51.016 --> 01:29:55.589
the standardization of it and
4928 range zip transform view.

01:29:56.709 --> 01:29:58.059
Should we just say 2?

01:29:59.319 --> 01:30:00.469
Or two one.

01:30:01.749 --> 01:30:03.659
If ease is an empty pack.

01:30:04.629 --> 01:30:06.459
But by all formed otherwise
this.

01:30:07.229 --> 01:30:08.489
I say just maybe 2.

01:30:14.419 --> 01:30:15.329
Um.

01:30:16.279 --> 01:30:18.579
Because that covers all the
expression equivalent.

01:30:19.269 --> 01:30:19.729
Umm.

01:30:20.729 --> 01:30:24.844
Maybe. Maybe we should explain.
Whoops, we should explain a

01:30:24.844 --> 01:30:27.999
little bit why we're nervous
about this, the.

01:30:29.409 --> 01:30:30.849
This thing here.

01:30:34.149 --> 01:30:36.339
In the current comment.

01:30:38.349 --> 01:30:41.419
Is extremely strange.

01:30:42.089 --> 01:30:42.729
Umm.

01:30:45.219 --> 01:30:51.949
This is always no except so
there is no reason to mention.

01:30:52.949 --> 01:30:53.559
It.

01:30:56.559 --> 01:30:57.039
Here.

01:31:00.809 --> 01:31:03.399
Came back should mentioned. We
saw that it's trying to match.

01:31:04.459 --> 01:31:05.009
Umm.

01:31:06.119 --> 01:31:08.169
The void aff here.

01:31:12.159 --> 01:31:15.929
Whoops. Whenever I magnify, it's
where, Umm, we saw that.

01:31:17.329 --> 01:31:21.777
It was trying to match law and
the standard ease, but simply

01:31:21.777 --> 01:31:26.445
citing the relevant paragraph is
easier and less confusing. OK,

01:31:26.445 --> 01:31:30.748
how's it sound? Casey and I
think that it would be simpler

01:31:30.748 --> 01:31:34.759
to cite N 4928 range ZIP
transform overview two in the

01:31:34.759 --> 01:31:39.426
current comment voids to decadal
funk ref is extremely strange.

01:31:39.426 --> 01:31:43.802
This is always no except so
there's no reason to mention it

01:31:43.802 --> 01:31:47.449
here. We saw that it was trying
to match it void.

01:31:47.529 --> 01:31:50.103
F in the standardese, but simply
sign the relevant paragraph is

01:31:50.103 --> 01:31:51.149
easier and less confusing.

01:31:52.999 --> 01:31:53.309
OK.

01:31:54.439 --> 01:31:58.449
Go back to preview and then and
then change the split.

01:32:00.379 --> 01:32:04.057
OK, slightly overtime, but I
think we can finish this very

01:32:04.057 --> 01:32:04.369
soon.

01:32:06.259 --> 01:32:09.809
OK, is invocation, no, except if
there's no types then.

01:32:11.029 --> 01:32:13.619
Is it true that it's always
true? UM.

01:32:14.749 --> 01:32:15.949
Yeah, we don't have to do
anything.

01:32:17.309 --> 01:32:18.599
Yes, it returns an empty view.

01:32:17.319 --> 01:32:18.849
As the transformation.

01:32:19.609 --> 01:32:19.899
Yeah.

01:32:20.649 --> 01:32:22.549
And everything to do with MTV is
no except.

01:32:21.019 --> 01:32:22.279
Otherwise return.

01:32:23.299 --> 01:32:23.739
OK.

01:32:25.349 --> 01:32:28.462
Otherwise, let me split this a
bit more. Otherwise return no.

01:32:28.462 --> 01:32:31.375
Except can we make a zip
transform view with parentheses?

01:32:31.375 --> 01:32:34.439
Because that's what we do for
views out of stood decal funk.

01:32:35.629 --> 01:32:38.735
And that is matching the F and
then stood decl types dot and

01:32:38.735 --> 01:32:40.009
that's matching the ease.

01:32:40.669 --> 01:32:40.959
OK.

01:32:42.209 --> 01:32:43.589
Because.

01:32:44.359 --> 01:32:46.239
Otherwise it would attempt to
construct.

01:32:47.569 --> 01:32:50.394
The transform view from just the
funk and that would be weird, is

01:32:50.394 --> 01:32:51.079
that the theory?

01:32:55.379 --> 01:32:58.235
Or try to figure out like why do
we need the special case here at

01:32:58.235 --> 01:32:58.409
all?

01:32:59.219 --> 01:33:03.624
Because you cannot instantiate
zip transform view with zero

01:33:03.624 --> 01:33:04.139
ranges.

01:33:05.629 --> 01:33:08.852
It's statically forbidden by the
constraints on the class

01:33:06.109 --> 01:33:06.999
Ah.

01:33:08.852 --> 01:33:12.353
template so that we don't have
to make it make sense or have a

01:33:10.139 --> 01:33:10.909
Ah.

01:33:12.353 --> 01:33:13.799
specialization just for 0.

01:33:14.869 --> 01:33:18.089
OK, but the the the zip
transform view.

01:33:18.989 --> 01:33:21.449
This thing the object, this is
the one that.

01:33:20.239 --> 01:33:24.628
Views colon, colon zip transform
will accept 0 ranges, sure, and

01:33:22.269 --> 01:33:22.669
Yeah.

01:33:23.739 --> 01:33:26.009
Zero and expect something to be
piped to it.

01:33:24.628 --> 01:33:25.169
it yeah.

01:33:27.729 --> 01:33:28.399
I think right.

01:33:29.699 --> 01:33:29.989
No.

01:33:30.939 --> 01:33:32.299
No, OK, that's not how.

01:33:33.579 --> 01:33:35.809
OK, but OK, it'll accept nothing
then, OK.

01:33:35.299 --> 01:33:38.649
Ohh does it take a count? It
probably doesn't.

01:33:40.189 --> 01:33:43.601
It's hard to do that piping
thing with things that take

01:33:43.601 --> 01:33:47.501
arbitrary numbers of branches,
likes of view and sip transform.

01:33:47.279 --> 01:33:50.189
Ah OK Ohh, because it because it
needs to take two things.

01:33:47.501 --> 01:33:51.402
So I suspect that they are not
rigid after objects. Yeah, right

01:33:51.039 --> 01:33:52.069
Ah OK, got it.

01:33:51.402 --> 01:33:54.875
there CPO's, but not range
adaptor objects in the in the

01:33:54.875 --> 01:33:57.679
wording, so they don't need to
do the piping.

01:33:56.219 --> 01:33:56.659
OK.

01:34:00.119 --> 01:34:03.835
OK, I think I've mostly followed
what's happening here. Man, this

01:34:03.835 --> 01:34:06.369
stuff is complicated. OK, so now
enable CPO.

01:34:07.589 --> 01:34:10.974
Template class under score kept
perfect class dot under score

01:34:10.974 --> 01:34:14.414
kept type static. Expert Bowl
enables CPO. Also ugly no except

01:34:14.414 --> 01:34:17.636
if constexpr precise dot types
is zero. OK so more special

01:34:17.636 --> 01:34:18.019
casing.

01:34:19.109 --> 01:34:23.407
I'm guessing that's this using
under score capital. Decayed

01:34:23.407 --> 01:34:26.059
funk is deck T funk. That's this
FD.

01:34:26.949 --> 01:34:30.521
OK, so this is matching the path
standard ease which Tyler

01:34:30.521 --> 01:34:33.731
sighted. If Constexpr move
constructible FD which is

01:34:33.731 --> 01:34:36.819
decayed funk and regular
invocable FD ref which is

01:34:36.819 --> 01:34:37.849
decayed funk RAF.

01:34:38.669 --> 01:34:41.459
OK, this says if it's false.

01:34:42.229 --> 01:34:44.749
Or if the Katie blah is not an
object type.

01:34:45.409 --> 01:34:49.109
OK, so hold on. If I think we're
organizing this.

01:34:51.429 --> 01:34:56.359
If this thing is true and if
blah is an object type.

01:34:58.359 --> 01:35:00.239
Are we not checking the object
type bit here?

01:35:04.409 --> 01:35:05.159
Why is there?

01:35:08.989 --> 01:35:11.369
OK, I'm a little concerned that
we're not checking this bit.

01:35:12.439 --> 01:35:14.269
OK, but let's skip that for now.

01:35:16.329 --> 01:35:20.482
If law and blah is false, then
itself harmed. So let's test if

01:35:20.482 --> 01:35:24.108
constexpr move constructible,
decayed funk and regular

01:35:24.108 --> 01:35:25.889
invocable decayed func ref.

01:35:26.599 --> 01:35:29.609
One is true. Do cool thing. If
it's false then itself formed.

01:35:31.099 --> 01:35:34.269
OK. Ah. OK. So then if it's
true.

01:35:32.479 --> 01:35:35.609
Or they're using not void
instead of is object.

01:35:36.429 --> 01:35:39.954
Yeah, I think I think that's
what it's being decayed. So it

01:35:36.989 --> 01:35:38.199
Is that is that the problem?

01:35:39.954 --> 01:35:41.599
might end up being the same.

01:35:43.049 --> 01:35:46.134
That's an interesting shortcut,
so let's see if this is correct.

01:35:46.134 --> 01:35:47.179
Invoke result TFD ref.

01:35:48.419 --> 01:35:49.159
And then.

01:35:49.939 --> 01:35:53.500
The Standardese says The thing
is, well, The thing is well

01:35:53.500 --> 01:35:56.459
formed when the decay of that is
an object type.

01:35:57.099 --> 01:35:57.749
Umm.

01:35:59.499 --> 01:36:04.570
Decay transforms well, first the
strips off references and CVS

01:36:04.570 --> 01:36:09.641
and it transforms functions to
function pointers and arrays to

01:36:09.641 --> 01:36:10.929
object pointers.

01:36:12.169 --> 01:36:15.817
So that's like all the stuff
that you could possibly return

01:36:15.817 --> 01:36:19.527
from a function. A function
either returns like an object or

01:36:19.527 --> 01:36:23.236
reference or void. We've already
decayed away references, so

01:36:23.236 --> 01:36:27.128
you're gonna get an object type,
possibly a function pointer or

01:36:27.128 --> 01:36:30.716
array element object pointer,
unless it's void. So I think

01:36:30.716 --> 01:36:33.514
this is a correct
simplification. What do you

01:36:33.514 --> 01:36:33.879
think?

01:36:34.489 --> 01:36:37.635
Umm that instead of checking
decay and object type this just

01:36:37.635 --> 01:36:40.988
says hey you invoke result. Are
you any kind of void? If you are

01:36:40.988 --> 01:36:41.969
then this is bogus.

01:36:46.889 --> 01:36:49.179
I think so. I'm agreeing for
now.

01:36:50.069 --> 01:36:50.479
OK.

01:36:51.169 --> 01:36:54.709
I'm gonna go look at the primary
type categories, but I agree.

01:36:51.609 --> 01:36:52.389
Do you think it's worth?

01:36:54.769 --> 01:36:57.459
I do you think it's do you think
it's worth comment?

01:36:58.899 --> 01:37:00.329
It's an interesting
transformation.

01:37:08.099 --> 01:37:11.167
I don't necessarily think it's
worth coming, but are you usual

01:37:11.167 --> 01:37:14.285
rules? If you do anything super
clever, then you should come in

01:37:14.285 --> 01:37:17.256
it to a record. How clever you
were and B avoid having other

01:37:17.256 --> 01:37:20.179
maintainers wonder what you were
doing. I think it deserves

01:37:19.629 --> 01:37:20.319
Yes.

01:37:20.179 --> 01:37:20.569
comment.

01:37:22.669 --> 01:37:24.279
OK, I will complete.

01:37:24.489 --> 01:37:27.749
This OK, unless like you look
into it.

01:37:25.749 --> 01:37:28.079
I do now completely agree that
it's correct.

01:37:29.169 --> 01:37:31.725
OK. Well, yeah, certainly if you
don't think it's possibly

01:37:31.725 --> 01:37:34.282
correct, then it definitely
deserves a comment. But if you

01:37:34.282 --> 01:37:36.969
can find that it's incorrect
then then we should also fix it.

01:37:36.969 --> 01:37:38.139
This appears to be correct.

01:37:39.869 --> 01:37:42.649
Casey Carter is going to verify.

01:37:43.119 --> 01:37:43.769
No, I did.

01:37:43.179 --> 01:37:43.769
Umm.

01:37:44.859 --> 01:37:47.799
Ohh you you. Oh, you did. OK, so
you think it is correct but.

01:37:46.629 --> 01:37:49.555
I did I I went and looked at all
the primary type type categories

01:37:49.555 --> 01:37:52.216
and yes, void is the only thing
that a function can return.

01:37:52.216 --> 01:37:53.369
That's not an object type.

01:37:55.289 --> 01:37:56.739
CPP Boyd to be precise.

01:37:56.789 --> 01:37:57.829
Do you think it merits a
comment?

01:38:00.259 --> 01:38:03.012
I don't know we we both were
concerned that it was wrong

01:38:03.012 --> 01:38:06.199
initially, but we figured out in
however many minutes that it was

01:38:06.199 --> 01:38:07.649
right. Does that close enough?

01:38:07.519 --> 01:38:11.145
Yeah, but those minutes were
powered by years and years of

01:38:11.145 --> 01:38:14.833
suffering. Through looking at
type traits. So maybe to save

01:38:14.833 --> 01:38:18.275
other contributors from
similarly brain exponent. Yeah,

01:38:15.249 --> 01:38:16.249
Alright, fair enough.

01:38:18.099 --> 01:38:19.789
Fair enough. Let's throw a
comment.

01:38:18.275 --> 01:38:22.208
I'm trying to think of. Yeah. Or
in order to save us some time,

01:38:22.208 --> 01:38:25.896
5-10 years down the road, once
we've forgotten all of these

01:38:25.896 --> 01:38:27.679
things, which is more likely.

01:38:30.279 --> 01:38:32.929
OK, I think here we should
probably again just simply cite

01:38:32.929 --> 01:38:35.759
range of transform overview, but
here we can cite bullet .211.

01:38:36.339 --> 01:38:37.179
UM.

01:38:40.519 --> 01:38:43.589
Ah, the KT. So two on one.

01:38:47.419 --> 01:38:47.889
Umm.

01:38:48.619 --> 01:38:48.849
But.

01:38:50.069 --> 01:38:52.019
A, C and I.

01:38:53.079 --> 01:38:55.489
Had to think for a moment.

01:38:56.419 --> 01:38:57.829
To.

01:38:58.619 --> 01:39:01.889
Understand what was happening.

01:39:04.579 --> 01:39:07.799
It would be good to comment.

01:39:08.619 --> 01:39:09.379
This.

01:39:10.189 --> 01:39:11.539
By sighting.

01:39:13.089 --> 01:39:13.859
Blah.

01:39:19.159 --> 01:39:20.269
Come with this by.

01:39:22.429 --> 01:39:25.733
Saying that it implements,
should we say implements more

01:39:25.733 --> 01:39:26.429
efficiently?

01:39:28.759 --> 01:39:29.899
Or just implements blah.

01:39:31.819 --> 01:39:32.629
Maybe more efficiently.

01:39:36.169 --> 01:39:38.267
OK, this is a correct
transformation that standardese.

01:39:38.267 --> 01:39:40.747
But Casey and I had to think for
a moment to understand what was

01:39:40.747 --> 01:39:42.998
happening. It would be good to
comment this by saying that

01:39:42.998 --> 01:39:45.401
implements range, zip transform
Overview 211 more efficiently.

01:39:45.401 --> 01:39:47.729
Oh, and I forgot the standard.
We should always cite the WP.

01:39:49.179 --> 01:39:50.359
When we say paragraph numbers.

01:39:52.579 --> 01:39:55.310
OK, great. Did I make that
mistake elsewhere when we cite

01:39:55.310 --> 01:39:55.829
paragraphs?

01:39:56.539 --> 01:39:58.639
Umm, no, I got it right there.

01:39:59.609 --> 01:40:00.119
OK, good.

01:40:02.039 --> 01:40:04.109
OK, otherwise return false.

01:40:09.389 --> 01:40:12.851
And I was wondering, can we just
simply smash this together with

01:40:12.851 --> 01:40:16.048
like and and? But I think the if
constexpr person needed to

01:40:16.048 --> 01:40:18.819
needed to delay evaluation of
this invoke result T.

01:40:21.519 --> 01:40:23.509
No, we're already incisive dot
types.

01:40:30.849 --> 01:40:33.611
It seems like this whole thing
could be simplified to if

01:40:33.611 --> 01:40:35.259
constexpr blah and blah and
blah.

01:40:36.039 --> 01:40:37.799
Rather than the return false,
what do you think?

01:40:42.409 --> 01:40:45.882
Move constructible. Ohh, we
don't know regular invocable

01:40:43.829 --> 01:40:44.789
Maybe.

01:40:45.882 --> 01:40:46.979
until we get here.

01:40:48.329 --> 01:40:50.950
Yeah, I think this is the the
way it has to be phrased,

01:40:50.950 --> 01:40:53.898
because if you don't know that
decayed funk ref is regular and

01:40:53.898 --> 01:40:56.707
vocable, then you can't say
invoke result T it would scene.

01:40:56.707 --> 01:40:59.515
But in this context would be
hard error. So I think this is

01:40:59.515 --> 01:41:00.639
necessary unfortunately.

01:41:01.839 --> 01:41:04.989
Umm, OK, so what's going on
here?

01:41:07.729 --> 01:41:10.637
Wow clang format. What are you
even doing? I was like, I can't

01:41:10.637 --> 01:41:12.069
even parse this, but it's like.

01:41:10.779 --> 01:41:13.459
Yeah, I'm very disturbed. I
commented about this in chat.

01:41:14.209 --> 01:41:17.349
OK, Shi had a comment here that
suppress clang format.

01:41:17.909 --> 01:41:19.279
Yes, I think so.

01:41:19.159 --> 01:41:19.529
OK.

01:41:20.159 --> 01:41:23.019
At the very least, for those
lines in the else clause.

01:41:20.189 --> 01:41:20.839
Umm.

01:41:22.269 --> 01:41:22.589
Hey.

01:41:23.519 --> 01:41:26.929
Yeah, Clang format has really.

01:41:28.709 --> 01:41:32.899
Mess this up. We think it
merits.

01:41:33.689 --> 01:41:35.499
A suppression here.

01:41:40.369 --> 01:41:43.956
OK. Umm, otherwise, uh, I guess
that's this thing. Return

01:41:43.956 --> 01:41:47.729
requires given a funk rough ref
under function types ref dot

01:41:47.729 --> 01:41:51.130
under args can we make zip
transform view out of stood

01:41:51.130 --> 01:41:54.409
forward functions stood four
types args dot OK good.

01:41:55.439 --> 01:41:58.930
And the last bit public template
class, under score capital fund,

01:41:58.930 --> 01:42:02.369
class dot under score kept types
requires enable CPO funk types.

01:42:03.149 --> 01:42:04.609
There should be no discard.

01:42:05.539 --> 01:42:07.649
Because why would you invoke the
thing unless you want to use it?

01:42:09.939 --> 01:42:13.680
Constexpr auto operator Prinn
Pren take a funk. Refer a

01:42:13.680 --> 01:42:17.756
function typestuff.org Const
strengthening no except when is

01:42:17.756 --> 01:42:20.629
invocation noexcept. Given funk
and types.

01:42:21.379 --> 01:42:24.889
If constexpr size types is 0
then using.

01:42:25.519 --> 01:42:29.169
Decayed funk is decayed. T of
the decal type of function.

01:42:30.259 --> 01:42:31.689
Wrapped in parens.

01:42:32.779 --> 01:42:33.569
Interesting.

01:42:35.149 --> 01:42:38.805
Do we need to wrap it in parens?
If we don't, we will get funk

01:42:38.805 --> 01:42:41.069
riff Raff, but we're decaying
anyways.

01:42:42.479 --> 01:42:44.689
If we do wrap in parens, we
always get an L value.

01:42:45.389 --> 01:42:46.679
But then we decayed anyways.

01:42:48.529 --> 01:42:49.409
It's not harmful.

01:42:50.169 --> 01:42:51.259
It's a little weird.

01:42:54.749 --> 01:42:55.759
I'll accept it.

01:42:55.169 --> 01:42:59.343
They're trying to reflect
something in the specification

01:42:59.343 --> 01:43:00.369
with that and.

01:43:00.729 --> 01:43:01.149
Ohh.

01:43:01.539 --> 01:43:05.415
They're probably wrong to do so,
so it they're really

01:43:05.415 --> 01:43:06.349
questionable.

01:43:07.319 --> 01:43:08.209
Why we're doing that?

01:43:09.479 --> 01:43:11.509
OK. You think the punch should
be emitted here?

01:43:12.169 --> 01:43:15.745
Because we just immediately
decay. Ohh no, here it is. Let

01:43:15.745 --> 01:43:18.049
FDB decay T decltype double
parent F.

01:43:18.889 --> 01:43:19.299
OK.

01:43:21.709 --> 01:43:24.951
It's what the standard says, so
deviating from that is weirder,

01:43:24.951 --> 01:43:26.319
so I'm I'm happy with this.

01:43:26.209 --> 01:43:30.369
So decltype double printf is
bunk refresh.

01:43:32.099 --> 01:43:32.529
Right.

01:43:33.129 --> 01:43:35.767
And then we go to K that away.
So probably the standard is

01:43:35.767 --> 01:43:37.019
doing something unnecessary.

01:43:37.529 --> 01:43:41.079
Decltype printer in function is
funk ref.

01:43:43.129 --> 01:43:46.824
So they're using it. They're
using a different type than what

01:43:43.409 --> 01:43:46.789
Uncraft. Ohh. Because we have a
name.

01:43:46.824 --> 01:43:47.659
the spec says.

01:43:48.339 --> 01:43:48.779
Yeah.

01:43:49.459 --> 01:43:51.609
But at the end of the day, they
want to.

01:43:53.449 --> 01:43:55.469
They should just be using decay
T funk.

01:43:57.399 --> 01:44:01.153
Oh, good point. Like? Yeah, why
bother with the ref we already

01:44:01.153 --> 01:44:04.669
have? We're already in the type
domain. I'd like that. OK.

01:44:03.119 --> 01:44:03.319
Yeah.

01:44:04.399 --> 01:44:08.119
It's very confused by using decl
type of this thing that we know

01:44:08.119 --> 01:44:10.809
that decl type of because we
just declared it.

01:44:11.749 --> 01:44:15.425
And yeah, it would be much
clearer if this was just Ducati

01:44:11.959 --> 01:44:13.059
Yeah. OK.

01:44:15.425 --> 01:44:16.049
funk done.

01:44:16.409 --> 01:44:20.999
So the standard says, UM, law.

01:44:28.719 --> 01:44:35.529
Umm, because it's phrased in
terms of on expression.

01:44:36.369 --> 01:44:41.519
Let FBA what is sub expression
of a subexpression.

01:44:43.539 --> 01:44:48.349
Russian F who's type it doesn't
already know.

01:44:48.789 --> 01:44:50.669
Umm here we have.

01:44:53.669 --> 01:44:57.579
Like rough rough function, so we
already know the type.

01:44:58.419 --> 01:45:00.339
And notably.

01:45:03.949 --> 01:45:04.939
Friend function.

01:45:05.899 --> 01:45:08.789
Is always on.

01:45:10.099 --> 01:45:13.036
L value that that that is a
difference, right? Brent

01:45:13.036 --> 01:45:16.139
functions always null value
cause functions got a name,

01:45:16.139 --> 01:45:19.464
whereas Brent F could be paren
of some PR value or whatever

01:45:19.464 --> 01:45:22.679
expression. So it's not always
an L value. Is that right?

01:45:24.349 --> 01:45:25.839
Yeah, give or take.

01:45:27.909 --> 01:45:35.068
OK, close enough. Unlike Dev, so
there's all ready a semantic

01:45:35.068 --> 01:45:36.339
difference.

01:45:36.759 --> 01:45:42.069
Umm. Ultimately we're passing
the result to.

01:45:42.779 --> 01:45:48.459
Decay team, so it doesn't really
matter but.

01:45:48.539 --> 01:45:54.996
And again, I'll blame you, case,
Carter. And I think it would be

01:45:54.996 --> 01:45:57.679
simpler to say decade funk.

01:46:01.029 --> 01:46:01.999
And better for throughput.

01:46:03.289 --> 01:46:03.699
Yes.

01:46:10.299 --> 01:46:12.849
OK, the standards has let FDB,
to KT decltype double printf

01:46:12.849 --> 01:46:15.655
because it's phrased in terms of
a sub expression F whose type it

01:46:15.655 --> 01:46:18.205
doesn't already know. Here we
have funk ref function, so we

01:46:18.205 --> 01:46:20.798
already know the type. Notably
paren function is always null

01:46:20.798 --> 01:46:23.519
value, unlike printf, so there's
already a semantic difference.

01:46:24.249 --> 01:46:27.112
Ultimately, we're passing the
result OK T so it doesn't really

01:46:27.112 --> 01:46:29.839
matter, but Casey and I think
would be simpler to say to KT

01:46:29.839 --> 01:46:31.249
funk and better for throughput.

01:46:32.219 --> 01:46:33.429
OK, so close.

01:46:34.249 --> 01:46:38.813
Uh equivalent, two OK is this
this is the same thing here.

01:46:38.813 --> 01:46:40.979
It's more directly matching.

01:46:44.079 --> 01:46:46.093
I'm less concerned about this
comma because it doesn't have

01:46:46.093 --> 01:46:46.799
that we're decl, Val.

01:46:47.789 --> 01:46:51.099
The comments technically wrong,
again because.

01:46:50.549 --> 01:46:51.789
Yeah, it's it's wrong again.

01:46:52.439 --> 01:46:56.247
And function in effort different
things, right? We we don't know

01:46:52.719 --> 01:46:53.129
OK.

01:46:55.559 --> 01:46:56.229
Yeah, yeah.

01:46:56.247 --> 01:46:59.938
what the type of the argument
expression F is. We can't really

01:46:59.938 --> 01:47:03.395
tell we we can tell what it's
decayed type is but we can't

01:47:03.395 --> 01:47:07.203
tell if it was a PR value or an
X value by the time it gets here

01:47:07.203 --> 01:47:10.309
because we had to bind a
forwarding reference to it.

01:47:11.249 --> 01:47:16.454
Right. And that's that's always
an L value. OK, so should we

01:47:16.454 --> 01:47:17.649
cite 212 here?

01:47:18.799 --> 01:47:21.943
Should we say site two and two
for this one as well because

01:47:21.943 --> 01:47:23.359
this is really the problem.

01:47:25.079 --> 01:47:27.495
I honestly don't know that I
would say anything for either of

01:47:25.289 --> 01:47:26.069
This F.

01:47:27.495 --> 01:47:27.729
these.

01:47:29.749 --> 01:47:32.099
OK, just drop it. Bridge is
certainly simpler.

01:47:31.569 --> 01:47:31.889
Yeah.

01:47:33.049 --> 01:47:35.889
I mean, we know we can see where
this is useful though.

01:47:33.809 --> 01:47:34.159
OK.

01:47:36.549 --> 01:47:39.420
So we know that it's supposed to
be implementing the exceptions

01:47:39.420 --> 01:47:40.049
specification.

01:47:40.849 --> 01:47:44.304
Or views block and therefore we
never go look at the spec of

01:47:41.079 --> 01:47:41.729
Yeah.

01:47:44.304 --> 01:47:47.872
views block to figure out why
this succession specification is

01:47:45.709 --> 01:47:46.159
And.

01:47:47.872 --> 01:47:49.459
so particularly complicated.

01:47:50.289 --> 01:47:53.139
Yeah, I agree. Unlike the
transformation here we we know

01:47:53.139 --> 01:47:56.139
what to look at so we can see,
oh, this implements that and

01:47:56.139 --> 01:47:59.289
it's not super mysterious what's
going on. OK, so let's update

01:47:59.289 --> 01:47:59.539
this.

01:48:00.229 --> 01:48:00.859
Umm.

01:48:04.439 --> 01:48:07.089
Drop this comment entirely.

01:48:11.829 --> 01:48:12.729
But.

01:48:13.709 --> 01:48:15.039
Readers of this.

01:48:15.309 --> 01:48:17.119
Commentation.

01:48:18.239 --> 01:48:19.029
Should.

01:48:19.819 --> 01:48:23.061
Already know to be looking at
the standard's side by side. OK,

01:48:23.061 --> 01:48:26.303
how does this look, Casey? And I
think they would be simply to

01:48:26.303 --> 01:48:29.288
drop this common entirely in the
current comment. Void is

01:48:29.288 --> 01:48:32.530
extremely strange. As always.
No, except I was trying to match

01:48:32.530 --> 01:48:35.155
void and Standardese, but
readers, readers of this

01:48:35.155 --> 01:48:38.397
implementation, she already know
to be looking at the standard

01:48:38.397 --> 01:48:38.809
subside.

01:48:39.949 --> 01:48:43.507
OK, so that applies to the whole
comment and then below I will

01:48:43.507 --> 01:48:45.259
also mention that this comment.

01:48:46.099 --> 01:48:46.579
Umm.

01:48:47.419 --> 01:48:48.829
Similarly.

01:48:50.769 --> 01:48:51.069
Or.

01:48:52.939 --> 01:48:58.309
Similarly to the comment
somewhat above.

01:48:59.609 --> 01:49:01.309
We think that.

01:49:02.469 --> 01:49:03.559
This comment.

01:49:04.469 --> 01:49:05.229
Should.

01:49:06.029 --> 01:49:08.009
I'm simply be dropped.

01:49:09.149 --> 01:49:12.519
OK, see notes that.

01:49:13.759 --> 01:49:14.259
Umm.

01:49:15.859 --> 01:49:18.539
This comment is subtly.

01:49:19.399 --> 01:49:22.469
Uh, wrong because void function.

01:49:24.179 --> 01:49:27.719
Is not quite the same as.

01:49:30.039 --> 01:49:31.999
Void F.

01:49:33.029 --> 01:49:35.379
In the standard ease.

01:49:36.269 --> 01:49:39.369
Better to avoid the headache and
tart.

01:49:40.539 --> 01:49:42.859
OK. Similarly to the comment
somewhere above, we think that

01:49:42.859 --> 01:49:45.296
this comment should simply be
dropped to Casey notes that this

01:49:45.296 --> 01:49:47.733
comment is subtly wrong because
void function is not quite the

01:49:47.733 --> 01:49:50.170
same as void F in the standard
is better to avoid the headache

01:49:50.170 --> 01:49:50.519
entirely.

01:49:51.169 --> 01:49:51.419
OK.

01:49:52.939 --> 01:49:56.792
Otherwise, we're going to return
an empty view of decay T. The

01:49:56.792 --> 01:50:00.401
invoke result T of decayed funk
Raff OK, that that's good.

01:50:00.401 --> 01:50:04.378
Otherwise return a zip transform
view. Straightforward functions

01:50:04.378 --> 01:50:08.109
strip four types, arcs export
stood in line, cuts expert zip

01:50:08.109 --> 01:50:11.718
transform fund zip transformer
experience, close namespace

01:50:11.718 --> 01:50:15.633
views. And let's make sure that
we're actually in C + 23, which

01:50:15.633 --> 01:50:17.469
I think we are because we are.

01:50:18.239 --> 01:50:20.823
Going to do ranges as container
let me scroll up before right

01:50:20.823 --> 01:50:22.699
after zip. We're good, which I
think we are.

01:50:23.649 --> 01:50:26.559
I forgot to check this
originally. Yeah, we just

01:50:26.559 --> 01:50:29.944
defined zip zip transform is
right alongside. There's no

01:50:29.944 --> 01:50:33.330
jumping out of 23 mode or
anything, so we're still in 23

01:50:33.330 --> 01:50:36.596
mode. OK, that is the product
code. Wow, that was very

01:50:36.596 --> 01:50:37.369
enlightening.

01:50:38.219 --> 01:50:41.919
And it's viewed. I have to come
back and review the test later.

01:50:42.529 --> 01:50:47.029
Umm, so I will request some
changes.

01:50:51.059 --> 01:50:51.659
Thanks.

01:50:52.879 --> 01:50:53.259
This.

01:50:54.099 --> 01:50:54.809
Looks great.

01:50:59.479 --> 01:51:05.750
We were all this time. I'll
blame myself. I was able to

01:51:05.750 --> 01:51:12.469
review all of the product code
during our video code review

01:51:12.469 --> 01:51:17.509
this week. I still need to look
at Test CPP.

01:51:18.869 --> 01:51:21.375
OK, thanks. This looks great. I
was able to review all the

01:51:21.375 --> 01:51:23.966
product code during our video
code review this week. I still

01:51:23.966 --> 01:51:26.557
need to look at Test CPP request
changes OK and I do think I

01:51:26.557 --> 01:51:28.469
submitted everything and nothing
is pending.

01:51:32.599 --> 01:51:37.715
OK, reviewed. Excellent. We did
it and we only ran like 30% over

01:51:37.715 --> 01:51:38.109
time.

01:51:39.589 --> 01:51:44.576
OK. And I, yeah, I think we we
learned a lot which is always

01:51:40.129 --> 01:51:40.909
It wasn't terrible.

01:51:44.576 --> 01:51:49.400
good. I don't see any questions
in the comments, only some

01:51:49.189 --> 01:51:49.489
Nope.

01:51:49.400 --> 01:51:51.199
commentary from Casey.

01:51:51.809 --> 01:51:55.171
I I give an explanation of why
Sentinel for incidental 4 don't

01:51:55.171 --> 01:51:56.399
have default arguments.

01:51:56.799 --> 01:51:59.659
Ah, OK, I guess I can repeat
that here.

01:51:58.679 --> 01:52:02.429
It took me a minute to remember
it. It's historical information.

01:52:01.729 --> 01:52:06.285
Uh, because it's it's it's a
type constraint because we say

01:52:05.989 --> 01:52:08.839
Yeah, we often use it as a type
constraint, yeah.

01:52:06.285 --> 01:52:07.349
Sentinel 4I S.

01:52:08.449 --> 01:52:09.269
Yeah.

01:52:10.029 --> 01:52:12.885
OK, so the default argument
would be too confusing that that

01:52:12.885 --> 01:52:15.694
makes sense. Yeah, I remember
seeing that type and strength

01:52:15.694 --> 01:52:18.504
thing and get confused about
where the type goes. So adding

01:52:18.504 --> 01:52:20.799
more confusion there would be
way too confusing.

01:52:19.909 --> 01:52:22.729
Make it even worse. Yeah. LLVM.
You hated it. And.

01:52:21.769 --> 01:52:22.209
Yeah.

01:52:23.549 --> 01:52:25.219
Yeah, we got rid of that quick.

01:52:26.989 --> 01:52:30.069
OK. So thanks for sticking
through this long code review.

01:52:30.069 --> 01:52:33.096
Thanks to Tyler Brawl for
submitting this awesome PR and

01:52:33.096 --> 01:52:36.388
getting us closer to having a
complete implementation of C is

01:52:36.388 --> 01:52:39.469
supposed 23 view zip the paper
we will see you next time.
