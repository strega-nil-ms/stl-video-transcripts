WEBVTT

00:00:09.720 --> 00:00:11.830
I just transcription as well.
Great.

00:00:15.500 --> 00:00:19.477
All right, so we've got vector
optimized, optimized vector move

00:00:19.477 --> 00:00:20.160
algorithms.

00:00:22.900 --> 00:00:26.581
This as a sheet of benchmark
results with it in Excel which

00:00:26.581 --> 00:00:27.440
was very nice.

00:00:29.510 --> 00:00:31.380
I'm not sharing this excel
window but.

00:00:32.250 --> 00:00:33.440
The results shall.

00:00:34.500 --> 00:00:36.650
Large improvements, which
doesn't surprise me.

00:00:37.910 --> 00:00:39.180
Because the.

00:00:40.340 --> 00:00:41.780
By large I mean.

00:00:42.470 --> 00:00:44.350
I'm up to three orders of
magnitude.

00:00:47.940 --> 00:00:49.230
So yeah, large.

00:00:50.180 --> 00:00:52.670
That doesn't surprise me,
because if we look.

00:00:53.720 --> 00:00:56.820
Umm, so we've got. Let's see
what do we have. We have changes

00:00:56.820 --> 00:00:58.920
to the build to the read me
these aren't.

00:01:00.870 --> 00:01:02.590
So as I just changing the
folder.

00:01:03.580 --> 00:01:05.210
It doesn't seem necessary to me.

00:01:21.700 --> 00:01:24.825
I think they might be
consistency improvements. If you

00:01:24.825 --> 00:01:28.063
expand the context above. I
haven't looked at this PR in

00:01:28.063 --> 00:01:29.710
detail, but I vaguely recall.

00:01:32.390 --> 00:01:35.339
It's the little blue context
thing right below the down

00:01:35.339 --> 00:01:35.760
Chevron.

00:01:37.930 --> 00:01:39.450
Uh, OK, that's a lot of context.

00:01:37.970 --> 00:01:40.460
While that extended the whole
thing, that's alright.

00:01:40.210 --> 00:01:43.348
Yeah. You, you, you don't wanna
hit that one, but now you can't

00:01:43.348 --> 00:01:43.740
undo it.

00:01:45.250 --> 00:01:45.810
I.

00:01:47.610 --> 00:01:48.530
This seems like.

00:01:49.480 --> 00:01:50.680
The opposite of.

00:01:52.070 --> 00:01:53.630
Maybe if you're doing.

00:01:56.580 --> 00:01:57.240
Ohh.

00:01:59.630 --> 00:02:00.240
Out.

00:02:04.620 --> 00:02:07.512
Are they just changing the? Read
me to agree with what the Cmake

00:02:04.750 --> 00:02:05.240
Yeah.

00:02:07.512 --> 00:02:08.090
already does.

00:02:09.550 --> 00:02:11.200
No, because this is.

00:02:13.280 --> 00:02:16.205
Like you, you've spent. This is
just specifying the build

00:02:16.205 --> 00:02:16.860
directory so.

00:02:20.190 --> 00:02:22.345
And then should be able to. You
know, you should be able to do

00:02:22.345 --> 00:02:22.960
whatever you want.

00:02:27.870 --> 00:02:30.888
Yeah. At the very least, it
doesn't seem related to the

00:02:30.888 --> 00:02:34.230
topic of the PR, and it should
probably be a separate change.

00:02:37.450 --> 00:02:38.900
Let's see if there's a.

00:02:43.560 --> 00:02:44.650
Let's see if uh.

00:02:53.690 --> 00:02:57.440
It it does contain a consistency
improvement like I I think the

00:02:57.440 --> 00:03:01.072
reason Misco might have noticed
this is when he was following

00:03:01.072 --> 00:03:04.470
the instructions the the
instructions by themselves can't

00:03:04.470 --> 00:03:08.220
even agree on where the output
directory is. Yeah there you go.

00:03:04.870 --> 00:03:05.370
Uh, here we go.

00:03:10.420 --> 00:03:11.290
Ohh OK.

00:03:12.280 --> 00:03:13.560
Yeah.

00:03:17.700 --> 00:03:19.070
OK. Yeah, that's fine then.

00:03:20.650 --> 00:03:25.117
Umm. I mean, yeah, I I don't
care that much. And and because

00:03:25.117 --> 00:03:27.240
you know it is unrelated but.

00:03:28.110 --> 00:03:30.820
Uh, it's a response to another.

00:03:32.460 --> 00:03:34.360
Uh, you know to something else.

00:03:35.120 --> 00:03:39.050
Class so I don't wanna be like,
no, don't do that because it's.

00:03:40.190 --> 00:03:43.360
That's, you know, it sucks to
have to ping pong around like

00:03:43.360 --> 00:03:44.100
that, alright?

00:03:44.890 --> 00:03:45.580
And we have.

00:03:45.720 --> 00:03:48.360
I'm Charlie. Before you get too
far into the review. Umm.

00:03:49.280 --> 00:03:52.087
It would you be comfortable with
the higher zoom? I'm just

00:03:52.087 --> 00:03:54.180
worried about our viewers in the
recording.

00:03:53.330 --> 00:03:53.680
Ohh yeah.

00:03:55.560 --> 00:03:56.780
At low resolutions.

00:03:56.480 --> 00:03:59.885
So this or can we do do the the
text separate from everything

00:03:59.885 --> 00:04:00.160
else?

00:04:01.400 --> 00:04:05.342
You can definitely crunch the
left pane down and you could use

00:04:05.342 --> 00:04:07.470
unified context if you like
that.

00:04:08.360 --> 00:04:09.490
I do like that.

00:04:11.390 --> 00:04:14.359
It's the button to the left of
changes from all commits that

00:04:14.359 --> 00:04:16.890
will crunch it to the left. And
yeah, there you go.

00:04:17.320 --> 00:04:19.490
Yeah. So that helps. How is
that?

00:04:20.870 --> 00:04:23.280
I think there should be a lot
more viewable. Thank you.

00:04:21.760 --> 00:04:22.460
One more check.

00:04:24.950 --> 00:04:29.530
Yeah. All right. So then we add
benchmarks, which are the tests.

00:04:31.780 --> 00:04:32.830
Umm.

00:04:38.260 --> 00:04:41.842
Add benchmark is under
benchmark. Yeah, this is a

00:04:41.842 --> 00:04:42.630
little bit.

00:04:46.850 --> 00:04:50.060
Of a deep, uh nesting, but we'll
see.

00:04:52.480 --> 00:04:55.840
We'll come back to that, see if
there's any good reason for

00:04:55.840 --> 00:04:56.120
that.

00:04:57.240 --> 00:04:59.340
And then we have see.

00:05:00.180 --> 00:05:04.300
Happy Benchmark Copy N benchmark
move, benchmark.

00:05:05.710 --> 00:05:10.053
The changes to vector and
changes to X utility. These

00:05:10.053 --> 00:05:11.500
appear to just be.

00:05:13.470 --> 00:05:18.030
It adds a level of like it of
indentation. Keeping all this

00:05:18.030 --> 00:05:19.170
stuff the same.

00:05:19.840 --> 00:05:23.930
And then also adds a call to
copy VIBOL which is in vector.

00:05:24.860 --> 00:05:25.750
Ah.

00:05:32.840 --> 00:05:33.930
Yeah, and I guess.

00:05:36.580 --> 00:05:37.300
Ohh.

00:05:37.960 --> 00:05:39.740
This is an ADL call.

00:05:43.760 --> 00:05:48.096
Yeah, this looks like an ADL
call to copy the bowl, which is

00:05:48.096 --> 00:05:50.300
why it can be inside X utility.

00:05:51.730 --> 00:05:56.470
Uh, without making a sad, but
also, that makes me sad.

00:05:59.980 --> 00:06:03.089
Umm, it's not even a DL's, just
dependent. Even if it were

00:06:03.089 --> 00:06:04.670
qualified it would still work.

00:06:07.020 --> 00:06:09.120
Oh, sorry, two phase. Look up.
I'm, I'm.

00:06:09.460 --> 00:06:10.040
No.

00:06:09.810 --> 00:06:11.440
I'm I'm saying wrong things.
You're right.

00:06:11.960 --> 00:06:15.620
Yeah, it's this is actual
utility which I don't believe.

00:06:22.830 --> 00:06:23.650
Yeah it does.

00:06:24.750 --> 00:06:28.500
Yeah, I I should totally doesn't
need vector.

00:06:31.070 --> 00:06:31.950
So.

00:06:33.080 --> 00:06:35.150
Yeah, this is a an. OK.

00:06:38.990 --> 00:06:41.720
Well, but how would we even fix
this? We'd have to.

00:06:43.410 --> 00:06:43.780
No.

00:06:46.930 --> 00:06:48.560
It would need to be declared.

00:06:50.500 --> 00:06:54.044
That's the the issue I guess. I
guess. Could you expand upon

00:06:54.044 --> 00:06:56.310
what we're very quickly talking
about?

00:06:54.060 --> 00:06:55.130
Yes. No.

00:06:57.260 --> 00:07:02.078
OK. So yeah, what we have here
is called a copy Bible is not

00:07:02.078 --> 00:07:03.420
qualified at all.

00:07:04.330 --> 00:07:08.018
On and you know the parameters
are the iterators, and are are

00:07:08.018 --> 00:07:11.349
all the iterators you passed
into the function, so it's

00:07:11.349 --> 00:07:12.420
clearly dependent.

00:07:13.300 --> 00:07:13.900
Uh.

00:07:14.630 --> 00:07:17.672
Like those arguments, make the
call dependent on the types of

00:07:17.672 --> 00:07:20.370
your template parameters,
because that's the types of.

00:07:21.110 --> 00:07:24.882
The arguments. This means it's
an ADL call and it's a

00:07:24.882 --> 00:07:25.580
dependent.

00:07:26.680 --> 00:07:31.310
80 I'll call and that means that
you trigger look up.

00:07:32.160 --> 00:07:36.620
Inside the instantiation context
of this template.

00:07:37.760 --> 00:07:40.240
Umm, which is why this works at
all.

00:07:41.320 --> 00:07:42.310
Because.

00:07:44.240 --> 00:07:48.457
This is an ex utility and copy.
The Bible is defined up in

00:07:48.457 --> 00:07:51.530
vector which is not included by
X utility.

00:07:52.940 --> 00:07:53.790
And so.

00:07:55.340 --> 00:07:56.630
Without this.

00:07:57.280 --> 00:08:02.295
You would only work if you if
you included vector previously

00:08:02.295 --> 00:08:07.391
to axe utility. As it is, it'll
work all the time because you

00:08:07.391 --> 00:08:08.460
can only get.

00:08:10.010 --> 00:08:13.616
It's difficult to get vector
bull iterators without having

00:08:13.616 --> 00:08:14.960
access to vector bool.

00:08:16.500 --> 00:08:18.400
And and it's looked up after you
know.

00:08:19.210 --> 00:08:24.110
At, you know, at the point where
you call, just copy, uncheck.

00:08:24.940 --> 00:08:25.510
Umm.

00:08:26.880 --> 00:08:28.390
But yeah, that's kind of nasty.

00:08:29.250 --> 00:08:34.510
And so STL suggestion is we
could declare it however.

00:08:35.570 --> 00:08:37.320
I mean this is an inline
function.

00:08:38.580 --> 00:08:39.080
Umm.

00:08:41.870 --> 00:08:44.910
So that declaration I think is
undefined behavior.

00:08:47.370 --> 00:08:52.251
No, it's OK to and this is not
actually marked, it's constexpr.

00:08:52.251 --> 00:08:53.700
You can declare it.

00:08:54.980 --> 00:08:57.895
And then later provided
definition and everything is OK

00:08:57.895 --> 00:09:01.122
as long as it's defined by the
end of the TU. Even if you use

00:09:00.170 --> 00:09:01.050
Yeah, but that's not.

00:09:01.122 --> 00:09:03.100
it in a constexpr context, I
believe.

00:09:05.010 --> 00:09:06.740
Yeah, but it's not always if
you.

00:09:11.210 --> 00:09:12.600
Like what if you call?

00:09:14.480 --> 00:09:18.413
Copy on when it on your own
container and you don't include

00:09:18.413 --> 00:09:19.330
vector at all.

00:09:20.940 --> 00:09:25.229
Then the if constexpr should not
activate and the branch should

00:09:25.229 --> 00:09:29.251
be consider dead. So the whether
copy V Bulls ever actually

00:09:29.251 --> 00:09:33.406
define should be moot. I'm like
95% sure that the Standardese

00:09:33.406 --> 00:09:34.210
works there.

00:09:34.810 --> 00:09:38.340
Yeah, that's right. It should
bind in nothing. It depends and

00:09:34.950 --> 00:09:37.310
The other thing the the other
thing is.

00:09:35.070 --> 00:09:35.680
Umm.

00:09:38.340 --> 00:09:41.812
the definition context, and you
know it's never looked up at

00:09:41.812 --> 00:09:44.260
parse time. So I'm sorry it
instantiation.

00:09:44.970 --> 00:09:48.290
Yeah. Also, I mean, if we do
just declare it then.

00:09:45.090 --> 00:09:45.710
So that's fine.

00:09:49.060 --> 00:09:49.630
Umm.

00:09:50.570 --> 00:09:52.810
I think it's a linker error in
the real world.

00:09:54.040 --> 00:09:57.359
Yeah, but, but you can't ever
see it. Yeah, OK, that's fine.

00:09:57.359 --> 00:10:00.570
But. But we have to declare it
inside this if context for.

00:10:02.020 --> 00:10:02.750
Ranch, right.

00:10:02.220 --> 00:10:02.850
No.

00:10:03.840 --> 00:10:06.558
Excuse me, it could be declared
outside and should be. It should

00:10:06.558 --> 00:10:08.900
just be declared top level, not
like within a function.

00:10:10.740 --> 00:10:13.302
Because if you look at the
signature, the signature of it

00:10:11.030 --> 00:10:11.460
I.

00:10:13.302 --> 00:10:15.732
doesn't care about V iterators
at all. It's completely

00:10:15.732 --> 00:10:16.350
unconstrained.

00:10:18.630 --> 00:10:22.636
Yeah, but I think even even just
having the that declaration

00:10:22.636 --> 00:10:26.642
appear if you didn't happen to
include vector and you're not

00:10:26.642 --> 00:10:29.400
gonna hit this branch, is UB
technically.

00:10:31.560 --> 00:10:35.495
I believe it's OK to declare a
constexpr function and then

00:10:31.860 --> 00:10:32.300
Why?

00:10:35.495 --> 00:10:37.830
never define it and never call
it.

00:10:39.810 --> 00:10:40.360
Ah.

00:10:40.810 --> 00:10:43.412
There, there should be no case
where providing a declaration

00:10:41.570 --> 00:10:42.310
It'll work.

00:10:43.412 --> 00:10:43.540
is.

00:10:44.060 --> 00:10:45.970
Umm by itself ill formed.

00:10:47.180 --> 00:10:47.510
Huh.

00:10:49.390 --> 00:10:52.171
Because because in C plus the
declaration is telling the

00:10:52.171 --> 00:10:52.610
compiler.

00:10:53.300 --> 00:10:56.123
I'm gonna have this thing. I'm
not gonna tell you what it is

00:10:56.123 --> 00:10:59.085
yet, but it's gonna be a name.
You. You get a notes, a class or

00:10:59.085 --> 00:11:02.046
function or whatever. There's no
actual like semantic checks or

00:11:02.046 --> 00:11:04.592
anything until you actually
provide a definition. It's

00:11:04.592 --> 00:11:05.980
always OK to just clear stuff.

00:11:12.100 --> 00:11:14.080
Umm, I think it's.

00:11:15.140 --> 00:11:18.950
I think technically just having
the declaration.

00:11:19.800 --> 00:11:21.490
Is you be, but it's not.

00:11:22.110 --> 00:11:24.310
Like it's not something that's
possible to check.

00:11:25.610 --> 00:11:26.220
Umm.

00:11:27.240 --> 00:11:30.181
And it works and I'll all the
compilers have the same

00:11:30.181 --> 00:11:31.760
behavior. And if you do that.

00:11:33.050 --> 00:11:33.520
Umm.

00:11:34.890 --> 00:11:35.670
But anyway.

00:11:50.580 --> 00:11:51.200
Umm.

00:11:52.810 --> 00:11:53.370
Ah.

00:11:57.280 --> 00:11:58.940
It is very annoying that it.

00:12:03.690 --> 00:12:07.309
Like if you somehow get those
vector bullet iterators then you

00:12:07.309 --> 00:12:10.870
get like a call instruction like
it's an actual linker error.

00:12:14.380 --> 00:12:15.090
That should be a.

00:12:16.370 --> 00:12:19.275
Worse than that, it's not a
linker error, it's it might be a

00:12:19.275 --> 00:12:21.560
linker error, but it might not
be depending on.

00:12:22.830 --> 00:12:24.100
The order of your object files.

00:12:23.210 --> 00:12:23.840
So.

00:12:24.750 --> 00:12:25.100
So.

00:12:26.190 --> 00:12:30.131
Yeah, the way to fix this that I
would propose is declare copy V

00:12:30.131 --> 00:12:33.647
bowl above, copy unchecked and
then that's it. Everything

00:12:33.647 --> 00:12:37.406
works. You never get a linker
error. You never get a compiler

00:12:37.406 --> 00:12:41.286
error if you call copy unchecked
with a non vectorable iterator

00:12:41.286 --> 00:12:44.984
then the if context branch is
not selected and everything is

00:12:44.984 --> 00:12:48.561
cool if you call it from with
the vector iterator then the

00:12:48.561 --> 00:12:52.198
definition of copy V bowl will
be available by the time you

00:12:52.198 --> 00:12:55.290
actually call the thing and then
everything works.

00:12:52.600 --> 00:12:53.150
Yeah, no.

00:12:56.110 --> 00:12:59.832
Yeah. So that's true. Like the
my concern is just that it could

00:12:59.832 --> 00:13:03.379
be error prone in the future
because you then have that name

00:13:03.379 --> 00:13:03.960
available.

00:13:04.720 --> 00:13:05.290
Umm.

00:13:06.450 --> 00:13:10.984
You know, throughout the rest of
the file, and if you happen to

00:13:10.984 --> 00:13:12.330
call it in a place.

00:13:13.130 --> 00:13:16.640
That could be reached without
having included vector.

00:13:17.520 --> 00:13:18.490
Bad things happen.

00:13:20.110 --> 00:13:23.243
In theory, yes, but in practice
copy V bowl is really only meant

00:13:23.243 --> 00:13:26.086
for vector iterators every
single you should be guarded by

00:13:26.086 --> 00:13:28.640
the sort of is VC iterator that
Misco is doing here.

00:13:29.850 --> 00:13:31.870
It seems extremely difficult to
get into trouble.

00:13:32.400 --> 00:13:35.620
Yeah, I yeah, I'm OK with just
declaring it up there, but I.

00:13:36.580 --> 00:13:39.280
We could declare it in at
functions scope too.

00:13:40.780 --> 00:13:44.190
I cannot think of any examples
in the STL where we have a

00:13:44.190 --> 00:13:46.660
function local declaration of a
function.

00:13:47.500 --> 00:13:49.800
Alright, if if there are no
other example.

00:13:47.880 --> 00:13:50.600
If I'm wrong, we should not be
doing that. That's squirrelly.

00:13:48.400 --> 00:13:50.100
It's not, it's a template, isn't
it?

00:13:51.650 --> 00:13:54.965
We can't have a function. We
have a block level declaration

00:13:51.660 --> 00:13:51.900
Yeah.

00:13:51.800 --> 00:13:52.830
And as a template, yeah.

00:13:54.965 --> 00:13:56.180
of a template, period.

00:13:56.800 --> 00:13:57.090
No.

00:13:59.140 --> 00:14:01.730
Yeah, that's a good point. I did
not remember that the template.

00:14:02.710 --> 00:14:05.979
And you could ask him to stood,
qualify it, since we're trying

00:14:05.340 --> 00:14:06.990
Yeah, well, yeah.

00:14:05.979 --> 00:14:07.640
to do that with ugly names then.

00:14:14.710 --> 00:14:15.080
And.

00:14:18.840 --> 00:14:21.750
Yeah, sorry I didn't clearly
cannot pronounce under score

00:14:21.750 --> 00:14:24.560
capital stood instead of colon,
colon, lowercase stood.

00:14:26.400 --> 00:14:27.710
Thank you for getting it
correct.

00:14:30.490 --> 00:14:35.140
Yeah. And then this all looks
identical, which is good.

00:14:40.230 --> 00:14:43.540
Yeah. Great. OK. So that's just
modifying.

00:14:44.870 --> 00:14:49.260
Yeah. And then this is the
actual test of.

00:14:50.490 --> 00:14:52.870
The actual functional test, not
the benchmark.

00:14:56.130 --> 00:14:56.410
Yeah.

00:14:57.840 --> 00:14:59.850
Umm, so let's look at.

00:15:00.980 --> 00:15:01.490
Vector.

00:15:02.860 --> 00:15:06.273
Umm, so my understanding then is
that previously what was

00:15:06.273 --> 00:15:09.922
happening was you would copy and
it would just go through the

00:15:09.922 --> 00:15:11.570
fallback copy path and like.

00:15:12.310 --> 00:15:14.840
Run all the iterator code
basically right like.

00:15:16.010 --> 00:15:19.625
Do you references the iterator
and copies over 1 little bool at

00:15:19.625 --> 00:15:20.020
a time?

00:15:21.050 --> 00:15:21.480
Uh.

00:15:22.540 --> 00:15:26.576
Resulting in you know lots of
ends in orders for for each

00:15:26.576 --> 00:15:27.620
individual bit.

00:15:29.320 --> 00:15:29.610
Hmm.

00:15:31.440 --> 00:15:33.050
So instead what we want to do.

00:15:31.590 --> 00:15:32.380
And I think it's.

00:15:34.140 --> 00:15:37.575
My understanding is that that's
catastrophic for the processor,

00:15:37.575 --> 00:15:40.794
right? Because every result
depends on the previous result,

00:15:40.794 --> 00:15:43.692
so it can't really do any work
with instruction level

00:15:43.692 --> 00:15:47.234
parallelism. And it's even worse
for performance than all the bit

00:15:47.234 --> 00:15:48.200
OPS might suggest.

00:15:48.690 --> 00:15:49.230
Yes.

00:15:48.980 --> 00:15:50.740
Is that right? OK.

00:15:51.040 --> 00:15:52.570
Yes, although.

00:15:53.660 --> 00:15:56.080
Since we're doing all the
iterator stuff too.

00:15:57.900 --> 00:16:01.700
It's possible. It's like doing a
bunch like it's doing.

00:16:03.450 --> 00:16:05.460
Calls or something in between
2:00.

00:16:07.340 --> 00:16:11.393
Especially in debug mode. But
yeah, it's not good, and even

00:16:11.393 --> 00:16:15.580
even discounting that, like all
the bid OPS are just kind of.

00:16:17.810 --> 00:16:19.130
Bad because like.

00:16:20.160 --> 00:16:21.420
Though like.

00:16:22.480 --> 00:16:25.390
In most cases, the resulting
word.

00:16:26.480 --> 00:16:29.922
Like the end result that you
need is already in the source

00:16:29.922 --> 00:16:30.330
vector.

00:16:32.490 --> 00:16:37.648
And this just So what we're
gonna do here, my understanding

00:16:37.648 --> 00:16:40.570
is we're figuring out where
like.

00:16:41.630 --> 00:16:43.340
Which which chunk?

00:16:44.250 --> 00:16:45.610
The beginning.

00:16:46.410 --> 00:16:48.380
Of the range to copy is in.

00:16:49.240 --> 00:16:52.676
And then we're figuring out
which bit is the start and then

00:16:52.676 --> 00:16:53.020
we're.

00:16:53.840 --> 00:16:57.711
Calling out that whole section,
copy it over, and then for any

00:16:57.711 --> 00:16:58.940
full chunks we just.

00:16:59.940 --> 00:17:01.200
Copy them directly.

00:17:01.890 --> 00:17:04.675
And then at the end we figure
out where it ends. If we copy

00:17:04.675 --> 00:17:05.510
just that portion.

00:17:07.320 --> 00:17:09.500
OK so.

00:17:12.500 --> 00:17:13.670
We unwrap.

00:17:17.210 --> 00:17:18.460
The iterator.

00:17:20.500 --> 00:17:23.510
You're a const cast. That's
weird.

00:17:31.730 --> 00:17:36.077
I believe this is because if you
look at the definition of VCBE

00:17:36.077 --> 00:17:40.085
iterator, it's the VB Const
iterator is the highest parent

00:17:40.085 --> 00:17:44.093
and then the modifiable iterator
derives from it using the

00:17:44.093 --> 00:17:48.304
constant one for storage. So my
putter is always a constar. I

00:17:47.870 --> 00:17:50.130
That's so cursed.

00:17:48.304 --> 00:17:50.070
think that's how it works.

00:17:51.140 --> 00:17:52.250
Yeah, it's pretty cursed.

00:17:53.150 --> 00:17:54.360
Is it always a rough winner?

00:17:53.320 --> 00:17:53.750
That's.

00:17:53.720 --> 00:17:54.380
This was.

00:17:55.230 --> 00:17:57.670
This is one of the first things
that I fixed in vnext.

00:17:57.760 --> 00:18:00.779
Uh, which is stranded in our TFs
branch, but they're the

00:18:00.779 --> 00:18:04.063
iterators are templated in a
consciousness and we do not have

00:18:01.210 --> 00:18:01.460
Yeah.

00:18:04.063 --> 00:18:07.400
one inheriting from the other,
which is actually nonconformant

00:18:07.400 --> 00:18:08.830
in some obscure situations.

00:18:11.640 --> 00:18:12.400
Yeah, well.

00:18:13.390 --> 00:18:16.571
Yeah, I'm. I'm OK with this.
With the contrast in this town

00:18:16.571 --> 00:18:19.964
in this context, but let's just
keep that in mind and make sure

00:18:19.964 --> 00:18:21.820
we're not writing to these
things.

00:18:22.940 --> 00:18:25.930
Umm. First last destination.

00:18:27.590 --> 00:18:28.400
Umm.

00:18:27.960 --> 00:18:31.400
Oh oh, that that's a good point.
You you bring up an excellent

00:18:31.400 --> 00:18:34.675
point. Why are VCBE first and
last modifiable? I mean, desk

00:18:34.675 --> 00:18:37.787
has to be because we got a
scribble to it. But first and

00:18:37.787 --> 00:18:41.172
last, we should never scribble
to those. Those should just be

00:18:41.172 --> 00:18:41.500
Const.

00:18:42.820 --> 00:18:43.250
Right.

00:18:44.000 --> 00:18:46.010
That is a good point.

00:18:47.090 --> 00:18:47.740
Let's.

00:18:48.470 --> 00:18:51.276
I can't wait to write a comment
until we're through more of

00:18:51.276 --> 00:18:51.510
this.

00:18:52.560 --> 00:18:55.130
Because it might be, it might
end up being self-explanatory.

00:18:56.250 --> 00:18:57.330
The end.

00:19:00.640 --> 00:19:01.240
Let's see.

00:19:05.060 --> 00:19:08.169
OK, yeah, this is just the end
of the destination range, which

00:19:08.169 --> 00:19:10.390
is destination. Yeah, what's the
difference?

00:19:11.790 --> 00:19:12.230
Uh.

00:19:17.040 --> 00:19:19.240
Or source mask. I believe this
should be the.

00:19:19.320 --> 00:19:19.630
But.

00:19:22.840 --> 00:19:27.551
The mask for cutting bits out of
the end of the first word and at

00:19:27.551 --> 00:19:30.620
least significant bits of the
first chunk.

00:19:31.880 --> 00:19:35.537
I don't it does vector bool
store word by word or double or

00:19:35.537 --> 00:19:35.720
or.

00:19:37.460 --> 00:19:37.950
Or.

00:19:38.640 --> 00:19:41.620
Like 8 or or bite by bite or
what?

00:19:44.940 --> 00:19:48.144
It's an unsigned int. Units of
unsigned INT, under score V

00:19:48.144 --> 00:19:51.510
base. I should say specifically
as an alias for unsigned INT.

00:19:53.030 --> 00:19:53.440
Alright.

00:19:54.200 --> 00:19:55.670
So these B based putters are.

00:19:56.510 --> 00:20:00.406
Are pointers to unsigned ints
that happen to be the 32 bits

00:19:57.340 --> 00:19:57.860
We'll say.

00:19:59.790 --> 00:20:00.860
We'll say in.

00:20:00.406 --> 00:20:04.497
sequence containing the begined.
I'm sorry, containing the one

00:20:04.497 --> 00:20:06.510
that the iterators pointing at.

00:20:06.570 --> 00:20:09.689
If I try and say double word by
double word I'm I'm knocking it.

00:20:09.689 --> 00:20:11.080
Remember to say consistently.

00:20:12.250 --> 00:20:12.710
Uh.

00:20:14.070 --> 00:20:15.720
And word is ambiguous anyway.

00:20:17.020 --> 00:20:18.730
OK, so this is all ones.

00:20:17.830 --> 00:20:18.330
And as.

00:20:19.460 --> 00:20:22.532
As an aside, Umm, we should,
although this is not the highest

00:20:22.532 --> 00:20:25.455
priority, it's good to make sure
the code is kind of being

00:20:25.455 --> 00:20:28.477
generic about what we base is
cause in the V next if we ever

00:20:28.477 --> 00:20:31.450
want to make V base 64 bits on
64 bit platforms it would be

00:20:31.450 --> 00:20:34.621
nice if as much code as possible
automatically worked, but it's

00:20:34.621 --> 00:20:35.760
not critical right now.

00:20:34.700 --> 00:20:38.678
Yeah, I think the the thing that
is not being generic about is if

00:20:38.678 --> 00:20:41.330
we ever wanna make it smaller
than 32 bits.

00:20:42.030 --> 00:20:45.060
This is not generic and I'm 100%
OK with that.

00:20:46.140 --> 00:20:48.110
Umm, that's not worth it.

00:20:49.420 --> 00:20:50.010
Umm.

00:20:51.180 --> 00:20:53.650
OK, so all ones shifted.

00:20:54.390 --> 00:20:55.960
Through the the offset.

00:20:57.550 --> 00:20:58.530
Umm.

00:20:59.690 --> 00:21:01.490
And for the destination, let's
see.

00:21:19.970 --> 00:21:21.780
Want all ones?

00:21:22.960 --> 00:21:25.200
OK. Yeah. So this is going to be
all ones.

00:21:27.690 --> 00:21:31.110
Uh, yeah, so, so all ones in the
unoccupied.

00:21:32.490 --> 00:21:33.220
Region.

00:21:40.420 --> 00:21:42.630
Except reversed from what I
would expect.

00:21:44.260 --> 00:21:47.060
The first, the first destination
mask.

00:21:47.920 --> 00:21:48.520
Umm.

00:21:50.490 --> 00:21:52.540
Is ones in the.

00:22:00.930 --> 00:22:02.760
We'll say rightmost.

00:22:03.460 --> 00:22:06.400
Places and the source is ones in
the left most places.

00:22:07.490 --> 00:22:07.960
Umm.

00:22:13.040 --> 00:22:14.600
Is is vectorable.

00:22:16.080 --> 00:22:17.930
Oh, that might just be endian
this.

00:22:21.100 --> 00:22:23.600
Umm. And then the.

00:22:24.450 --> 00:22:25.140
Uh.

00:22:28.170 --> 00:22:28.440
OK.

00:22:30.460 --> 00:22:33.222
Yeah, technically it's not
processor endianness because at

00:22:33.222 --> 00:22:36.312
no pointer reinspecting the byte
representation of the stuff, but

00:22:36.312 --> 00:22:38.980
vector bool does have a
preference for least significant

00:22:38.980 --> 00:22:42.070
or most significant where starts
filling from I always forget, so

00:22:42.070 --> 00:22:44.785
I always have to look it up.
Pretty sure Miss goes got it

00:22:44.785 --> 00:22:45.300
right here.

00:22:46.060 --> 00:22:48.520
Yeah, I mean it's arbitrary.

00:22:49.480 --> 00:22:50.860
You just have to be consistent.

00:22:52.030 --> 00:22:57.420
OK, so single block source. So
that's just if we only have one.

00:22:58.620 --> 00:23:02.303
Locke and we need to know that,
presumably because that means

00:23:02.303 --> 00:23:02.600
that.

00:23:03.530 --> 00:23:06.490
Are mask is double ended?

00:23:08.240 --> 00:23:12.100
Uh, same with the desks.

00:23:12.780 --> 00:23:14.170
The destination.

00:23:16.120 --> 00:23:16.900
Umm.

00:23:19.190 --> 00:23:21.280
I am surprised that we are.

00:23:22.650 --> 00:23:25.283
Doing this instead of just
unwrapping it, but we'll see if

00:23:25.283 --> 00:23:27.960
that comes up again. We might
just wanna unwrap it up here.

00:23:28.980 --> 00:23:30.250
Like you know, do this task.

00:23:32.260 --> 00:23:32.740
Umm.

00:23:45.490 --> 00:23:47.950
You already excluded first
equals last.

00:23:49.270 --> 00:23:50.240
Ohh, that's up here.

00:24:00.690 --> 00:24:03.950
Uh, yeah, so this is if you're
copying 0 elements.

00:24:04.810 --> 00:24:06.700
And so it's comparing both.

00:24:07.410 --> 00:24:09.810
Which block you're on and what
the offsets are.

00:24:11.790 --> 00:24:13.330
Umm, so this is when you're.

00:24:14.320 --> 00:24:16.210
Copying more than zero elements.

00:24:17.620 --> 00:24:19.230
Uh, last source mask.

00:24:21.750 --> 00:24:22.880
On shift.

00:24:25.410 --> 00:24:26.260
UM.

00:24:29.840 --> 00:24:31.940
This is going to be 32,
presumably.

00:24:33.090 --> 00:24:35.210
Minus whatever the offset is.

00:24:36.650 --> 00:24:37.270
Umm.

00:24:41.220 --> 00:24:43.430
And you're shifting OK.

00:24:45.530 --> 00:24:46.900
UM.

00:24:50.230 --> 00:24:52.120
And then we combine the masks.

00:24:56.190 --> 00:24:56.640
Ohh.

00:25:08.960 --> 00:25:11.700
Started the inverse of of of
what I was expecting. I zeros

00:25:11.700 --> 00:25:14.486
are gonna be where we're copying
from, which is why this is

00:25:14.486 --> 00:25:16.390
reversed from what I initially
expected.

00:25:18.170 --> 00:25:18.750
Umm.

00:25:25.720 --> 00:25:26.030
Or.

00:25:27.680 --> 00:25:28.030
Yeah.

00:25:30.840 --> 00:25:33.480
Umm, where is right shift set?

00:25:39.940 --> 00:25:41.200
OK, that's if.

00:25:51.440 --> 00:25:51.790
Huh.

00:26:00.120 --> 00:26:00.600
Uh.

00:26:01.990 --> 00:26:05.304
Ohh is right, shift is referring
to the direction of the copy,

00:26:05.304 --> 00:26:07.250
not the direction of the bit
shifts.

00:26:08.950 --> 00:26:09.590
I think.

00:26:14.330 --> 00:26:16.490
Ohh, it ends up being
equivalent.

00:26:18.060 --> 00:26:18.740
Umm.

00:26:23.510 --> 00:26:25.160
Ah, OK yeah, this is just.

00:26:28.490 --> 00:26:32.870
Now we shift by negative is is
my off unsigned.

00:26:34.280 --> 00:26:34.830
Probably.

00:26:36.750 --> 00:26:40.100
Uh, you cannot shift by
negative, it is undefined.

00:26:41.600 --> 00:26:42.070
Uh.

00:26:43.630 --> 00:26:47.447
So it's good that Minsky's being
very careful about that, just

00:26:47.447 --> 00:26:51.143
like he's being careful about
doing a full shift, which is a

00:26:51.143 --> 00:26:51.870
nonstandard.

00:26:56.660 --> 00:26:59.889
OK. Yeah. So that's what this is
doing. This is just shifting by

00:26:59.889 --> 00:27:01.330
the absolute value basically.

00:27:06.700 --> 00:27:08.390
Of the difference between.

00:27:09.700 --> 00:27:12.910
Yeah, but this is gonna so is
single block source.

00:27:14.120 --> 00:27:16.410
So this is about the
destination.

00:27:24.640 --> 00:27:25.000
But.

00:27:26.120 --> 00:27:29.994
We don't know if the destination
is in the same block as the

00:27:29.994 --> 00:27:31.010
source. Ohh but.

00:27:31.900 --> 00:27:35.534
It could be arbitrary, so this
is like realigning the vectors

00:27:35.534 --> 00:27:35.710
OK.

00:27:38.360 --> 00:27:39.720
Yeah. So there's like 3.

00:27:40.710 --> 00:27:43.280
Realigning things so that the
like.

00:27:45.060 --> 00:27:48.090
So that the part you're copying
looks like it would if.

00:27:51.170 --> 00:27:54.527
If the source and destination
had started out that had been at

00:27:54.527 --> 00:27:55.380
the same offset.

00:27:56.930 --> 00:27:59.506
Ohh, are you are you're bringing
up an interesting question. What

00:27:59.506 --> 00:27:59.740
about?

00:28:01.120 --> 00:28:05.500
Alias saying where they are
vectorable iterators into the

00:28:05.500 --> 00:28:10.107
same container. Is any overlap
permitted because we're doing

00:28:10.107 --> 00:28:14.110
something sneaky with the
processing word at a time.

00:28:15.340 --> 00:28:19.008
There is the whole special case
about you can't have concurrent

00:28:19.008 --> 00:28:22.504
accesses to separate elements of
vector, because they're not

00:28:22.504 --> 00:28:26.173
really separate. I don't think
the plane algorithm has that, so

00:28:25.210 --> 00:28:25.870
Well, I.

00:28:26.173 --> 00:28:29.898
are we just subject to the usual
one way overlapping restriction

00:28:28.850 --> 00:28:30.030
Yeah. However.

00:28:29.898 --> 00:28:30.070
on?

00:28:31.900 --> 00:28:32.670
However.

00:28:33.990 --> 00:28:35.180
Ohh yeah, so if.

00:28:36.910 --> 00:28:39.720
If it's subject to the usual one
way overlapping.

00:28:40.940 --> 00:28:42.210
I think we're OK.

00:28:43.610 --> 00:28:46.940
Because we're always reading in
full words.

00:28:48.000 --> 00:28:49.920
And then writing in full words.

00:28:52.450 --> 00:28:53.900
Oh, but if they all?

00:28:55.010 --> 00:28:57.280
And yeah, and we preserve.

00:28:59.480 --> 00:29:02.470
And I believe we preserve the.

00:29:03.460 --> 00:29:07.329
Parts of written when we write,
we preserve the parts that are

00:29:07.329 --> 00:29:09.110
outside the the copied range.

00:29:10.590 --> 00:29:11.380
Are you right?

00:29:10.680 --> 00:29:14.676
So you so you really do have to
have to be like strictly

00:29:14.676 --> 00:29:17.690
overlapping in the way that's
not allowed.

00:29:19.020 --> 00:29:22.324
Like in in the way that usually
cause that you know causes the

00:29:22.324 --> 00:29:23.320
usual problems for.

00:29:24.140 --> 00:29:25.360
Things to go badly.

00:29:26.620 --> 00:29:29.168
Yeah. Yeah, I think you're right
that we're essentially we're

00:29:29.168 --> 00:29:31.388
doing what the individual
operations would have done.

00:29:31.388 --> 00:29:32.210
We're just doing it.

00:29:32.920 --> 00:29:35.995
Up to 32 at a time. So and we're
careful to preserve the existing

00:29:35.995 --> 00:29:39.070
data, so I don't think we should
stop over anything and therefore

00:29:39.070 --> 00:29:41.819
we don't need extra aliases
checks because if we did, like

00:29:41.819 --> 00:29:42.890
my brain would explode.

00:29:43.970 --> 00:29:44.940
I think we're OK here.

00:29:45.440 --> 00:29:45.810
Yeah.

00:29:47.190 --> 00:29:49.390
But we should make sure that we
test that.

00:29:52.960 --> 00:29:55.700
So his single block desk? That
means that.

00:29:57.330 --> 00:29:58.500
We're in the same chunk.

00:30:01.200 --> 00:30:01.930
Then.

00:30:03.700 --> 00:30:07.868
Yeah, that's what this is doing.
So does mask is the the ones are

00:30:07.868 --> 00:30:09.320
where we preserve data.

00:30:19.670 --> 00:30:20.100
Oh no.

00:30:20.180 --> 00:30:21.440
Well, uh.

00:30:26.920 --> 00:30:28.150
Is this is gonna?

00:30:30.270 --> 00:30:31.180
Wherever the.

00:30:31.770 --> 00:30:34.700
I think you're right. The the
ones that were we preserve data.

00:30:36.470 --> 00:30:38.860
Because the parenthesized left
hand.

00:30:39.510 --> 00:30:43.122
Part of that expression says OK,
let's only preserve the bits of

00:30:43.122 --> 00:30:46.568
ebbs that aren't being messed
with, and then after wiping out

00:30:46.568 --> 00:30:50.069
to zeros all the stuff that we
want to overwrite, then we turn

00:30:50.069 --> 00:30:51.180
on the source, fail.

00:30:57.440 --> 00:31:01.389
Yeah, but we haven't. Let's see
where is source mask OHV for.

00:31:01.389 --> 00:31:04.955
OK. Yeah. So we've already
zeroed out. So we've both up

00:31:04.955 --> 00:31:06.420
here, we've zeroed out.

00:31:07.280 --> 00:31:11.420
The the bits that we don't wanna
copy. And down here we have.

00:31:12.390 --> 00:31:12.930
Umm.

00:31:14.180 --> 00:31:16.725
Zeroed out the bits we do want
to copy, and then we ordered in.

00:31:16.725 --> 00:31:17.560
That's fine, alright.

00:31:19.390 --> 00:31:20.520
Yeah, that makes sense.

00:31:22.650 --> 00:31:25.420
Than otherwise if.

00:31:27.440 --> 00:31:29.490
Let's see single broadcast.

00:31:35.380 --> 00:31:39.390
Otherwise you just do first ask
math that desk mask.

00:31:40.770 --> 00:31:42.060
Uh, which is?

00:31:45.070 --> 00:31:46.430
Year and.

00:31:51.190 --> 00:31:51.580
Yeah.

00:31:52.890 --> 00:31:53.660
Umm.

00:32:07.330 --> 00:32:09.240
It's not completely clear to me
that.

00:32:10.860 --> 00:32:14.390
Uh, we couldn't always compute,
you know.

00:32:15.960 --> 00:32:19.432
That always doing this is so bad
it, but it avoids a data

00:32:19.432 --> 00:32:20.090
dependency.

00:32:20.880 --> 00:32:21.990
And I don't really mind it.

00:32:23.430 --> 00:32:27.220
Umm. And I don't particularly
wanna play code golf with this.

00:32:29.680 --> 00:32:32.560
Yeah. OK. Then we go on to the
next destination.

00:32:40.720 --> 00:32:43.450
And last shift is.

00:32:47.930 --> 00:32:48.190
Huh.

00:33:08.700 --> 00:33:09.290
Ah.

00:33:10.240 --> 00:33:13.431
I see. So this this is just
doing the other half of the copy

00:33:13.431 --> 00:33:13.640
and.

00:33:14.670 --> 00:33:15.570
Because.

00:33:17.460 --> 00:33:21.485
Because we're in single block
source, that means that we can

00:33:21.485 --> 00:33:25.313
at most like the the biggest
range that we could possibly

00:33:25.313 --> 00:33:29.668
copy is 32, which can't possibly
span more than two blocks of the

00:33:29.668 --> 00:33:30.460
destination.

00:33:31.170 --> 00:33:33.908
And you can only be one break,
which is why they, which is why

00:33:33.908 --> 00:33:35.560
we just did the beginning in the
end.

00:33:36.360 --> 00:33:37.790
Directly here, OK.

00:33:40.260 --> 00:33:44.418
It would be kind of nice to
unify the the the tail, the

00:33:44.418 --> 00:33:46.200
processing of the tails.

00:33:47.980 --> 00:33:49.160
In each case.

00:33:52.980 --> 00:33:54.120
OK.

00:33:56.050 --> 00:33:57.030
UM.

00:34:00.910 --> 00:34:04.140
So this is just to keep it
constexpr in 20.

00:34:05.910 --> 00:34:10.170
I hate this a lot, but we do it
in various other places and.

00:34:10.970 --> 00:34:13.856
It's better than any other than
any alternative I can think of.

00:34:13.856 --> 00:34:15.840
It's better than hiding in them
in a macro.

00:34:17.230 --> 00:34:17.810
Umm.

00:34:19.990 --> 00:34:20.640
Let's see.

00:34:24.190 --> 00:34:26.410
Yeah. And that's just because we
need all this men move stuff.

00:34:27.820 --> 00:34:30.970
We could potentially make it
always constexpr or.

00:34:32.400 --> 00:34:33.130
I.

00:34:34.330 --> 00:34:37.423
Writing out the men move loop
manually and hoping that the

00:34:37.423 --> 00:34:39.100
optimizer can deal with it, but.

00:34:42.100 --> 00:34:42.550
Whatever.

00:34:42.390 --> 00:34:45.660
And then move exists because the
optimizer does not deal with it.

00:34:49.010 --> 00:34:49.320
Well.

00:34:51.500 --> 00:34:51.840
Yeah.

00:34:53.130 --> 00:34:53.620
Uh.

00:34:55.530 --> 00:34:57.410
So vbase 7.

00:35:03.900 --> 00:35:06.850
Ah, that is.

00:35:08.840 --> 00:35:09.890
Clever.

00:35:11.740 --> 00:35:12.720
As hell.

00:35:14.870 --> 00:35:19.582
So this is figuring out the
alignment of on a on a char by

00:35:19.582 --> 00:35:20.460
char level.

00:35:22.540 --> 00:35:23.180
Umm.

00:35:24.290 --> 00:35:25.110
So that if.

00:35:25.880 --> 00:35:28.760
The offset of your source range.

00:35:29.780 --> 00:35:32.410
So that if the destination is at
multiple of.

00:35:33.300 --> 00:35:33.880
Uh.

00:35:38.410 --> 00:35:40.170
Is a multiple of 8 like.

00:35:42.290 --> 00:35:42.840
Whereas.

00:35:46.340 --> 00:35:48.990
Is multiples of eight past your
your.

00:35:49.720 --> 00:35:51.200
Your source range.

00:35:52.310 --> 00:35:54.560
In offset, then you can.

00:35:56.360 --> 00:35:58.150
Uh, you can just use.

00:36:01.190 --> 00:36:01.870
Ma'am, copy.

00:36:04.770 --> 00:36:05.800
Let's say so.

00:36:07.480 --> 00:36:09.500
Or offset times 7.

00:36:21.500 --> 00:36:22.010
Yeah.

00:36:55.120 --> 00:36:59.190
Why is this end end 7 instead of
a some mod operation?

00:37:02.190 --> 00:37:03.860
It could be written as Mod 8.

00:37:06.470 --> 00:37:09.080
I don't actually know why
certain is ampersand 7.

00:37:11.130 --> 00:37:13.400
Umm, I mean, it's to make it.

00:37:14.840 --> 00:37:17.400
An end instruction server mod.

00:37:19.630 --> 00:37:20.250
I'm sure.

00:37:22.450 --> 00:37:22.700
But.

00:37:22.470 --> 00:37:25.690
I'm pretty I I would speculate
that the compilers people

00:37:25.690 --> 00:37:27.950
optimization should be able to
do that.

00:37:28.960 --> 00:37:32.528
Of course, in optimized mode, in
debug mode, you're right, it

00:37:32.528 --> 00:37:35.060
would probably emit a modulo by
a constant.

00:37:36.660 --> 00:37:37.090
Yeah.

00:37:38.130 --> 00:37:41.691
It's kind of strange that we're
using ampersand here, but we're

00:37:38.190 --> 00:37:38.770
I just didn't.

00:37:41.691 --> 00:37:42.860
happy to divide by 8.

00:37:43.710 --> 00:37:46.320
On 3790 through 3792.

00:37:47.500 --> 00:37:50.290
Oh yeah, that's a good point,
that division.

00:37:48.920 --> 00:37:52.776
It's like I'd expect to see and
in shift or mod and divide, but

00:37:52.776 --> 00:37:53.680
the mixture is.

00:37:52.920 --> 00:37:53.460
Yeah.

00:37:54.810 --> 00:37:55.440
Peculiar.

00:37:55.110 --> 00:37:55.490
Uh.

00:37:57.030 --> 00:37:58.400
Not that I care a whole lot
either way.

00:37:59.190 --> 00:38:02.840
It may be that the people
optimizer is not good enough.

00:38:03.860 --> 00:38:04.470
Umm.

00:38:22.820 --> 00:38:23.430
And give.

00:39:05.700 --> 00:39:08.770
But we know we know it doesn't
run in debug mode so.

00:39:10.060 --> 00:39:12.785
I might my recommend just
striking the second part of your

00:39:12.785 --> 00:39:15.556
comment and just say like it
should just be shifts. Like if

00:39:15.556 --> 00:39:18.419
we're gonna, we're gonna care
about debug code Gen. we should

00:39:18.419 --> 00:39:19.250
just do the shift.

00:39:23.330 --> 00:39:27.396
Don't we have president of doing
shifts elsewhere? Where did this

00:39:27.396 --> 00:39:30.600
come up? Was it caricom? No, it
was something else.

00:39:29.030 --> 00:39:29.210
We.

00:39:29.280 --> 00:39:32.829
Not an issue actually for a long
time we were doing shifts

00:39:32.829 --> 00:39:36.678
instead of divisions by two and
a lot of the algorithms because

00:39:36.678 --> 00:39:40.468
the people optimize are broke in
the back end and we've had to

00:39:40.468 --> 00:39:44.137
file an issue really filed the
issue prior to call precisely

00:39:41.390 --> 00:39:44.600
Ohh yeah, in in our quick sorts
and stuff, you're right.

00:39:44.137 --> 00:39:45.400
ticket at fixed yeah.

00:39:47.540 --> 00:39:51.679
Yeah, I don't really. I didn't
actually know about the modulo

00:39:51.679 --> 00:39:52.080
trick.

00:39:53.010 --> 00:39:56.148
I'm sure I've learned the
whatever underlying theorem

00:39:56.148 --> 00:39:58.240
makes that true at some point,
but.

00:39:59.040 --> 00:39:59.520
Umm.

00:40:01.270 --> 00:40:03.944
I guess I need to break out the
copy of hackers delight after

00:40:03.944 --> 00:40:04.160
this.

00:40:04.790 --> 00:40:07.210
Uh, But yeah, I like wish.

00:40:06.260 --> 00:40:09.150
You mean replacing replacing mod
8 by Ann 7?

00:40:09.650 --> 00:40:10.000
Yeah.

00:40:10.820 --> 00:40:14.624
That that's like it. It's so
it's own decimal. Like if you go

00:40:11.140 --> 00:40:11.490
Uh.

00:40:14.624 --> 00:40:18.490
like Moda thousand, you'll just
keeping the last three digits.

00:40:18.490 --> 00:40:22.356
So it's like ending with 999,
keeping only the last two digits

00:40:22.356 --> 00:40:23.890
with bitwise it's easier.

00:40:23.730 --> 00:40:24.730
No, that makes sense, yeah.

00:40:24.070 --> 00:40:24.530
Umm.

00:40:25.290 --> 00:40:28.227
Yeah, it's much harder to
explain the magic multiply

00:40:28.227 --> 00:40:30.720
trick. I don't have a cute
analogy for that.

00:40:31.210 --> 00:40:34.180
But the shift thing or or no.
Ohh no the.

00:40:33.690 --> 00:40:36.849
No, no, no, that that, that's
where if you divide by something

00:40:36.849 --> 00:40:39.907
that's not a power of two, you
can replace with the multiply

00:40:39.907 --> 00:40:41.060
and a shift your magic.

00:40:40.920 --> 00:40:44.130
Some cases. Yeah. Yeah, I I
think.

00:40:46.200 --> 00:40:48.040
At least with shifts, it's like.

00:40:51.630 --> 00:40:53.130
It's common enough that I.

00:40:55.740 --> 00:41:00.005
And just write it out it it's a
little weird but and and if we

00:41:00.005 --> 00:41:04.067
had a a, you know minus OG mode,
I would say just write the

00:41:04.067 --> 00:41:06.910
division like it's fine but we
don't. So.

00:41:08.470 --> 00:41:10.790
OK, so if.

00:41:11.420 --> 00:41:14.738
In the in the code above, I
wanna ask something in the

00:41:14.738 --> 00:41:16.910
middle line if you scroll up 1
bit.

00:41:18.720 --> 00:41:23.523
Line 3791 how do we feel about
that, saying unaligned first

00:41:23.523 --> 00:41:28.405
bits being used with dest? It
looks like a copy paste error.

00:41:28.405 --> 00:41:33.207
It's not because 3787 just
proved that unaligned first bits

00:41:33.207 --> 00:41:38.490
is equal to unaligned best bits,
but it seems very suspicious to.

00:41:39.290 --> 00:41:41.920
Take advantage of that on line
3791.

00:41:48.410 --> 00:41:51.980
I think it's, I mean this code
is inherently.

00:41:53.540 --> 00:41:55.060
Like it requires that.

00:41:55.870 --> 00:41:58.920
That they be aligned in the same
way for what it's about to do.

00:41:59.470 --> 00:42:04.053
Oh, I I certainly don't dispute
the need for 3787. My question

00:42:04.053 --> 00:42:06.090
is purely stylistic on 3791.

00:42:06.810 --> 00:42:10.432
Should we say unaligned desk
bits so we match up exactly

00:42:09.570 --> 00:42:10.170
Uh, yeah.

00:42:10.432 --> 00:42:14.245
first? My off first bits desk,
my off desk bits last my off

00:42:14.245 --> 00:42:14.880
last bits.

00:42:15.480 --> 00:42:16.220
Umm.

00:42:18.680 --> 00:42:20.690
Alright then, alright.

00:42:24.640 --> 00:42:24.960
Yeah.

00:42:26.850 --> 00:42:29.611
Because when I notice that I was
like, wait, is that wrong? Oh,

00:42:29.611 --> 00:42:30.560
wait, it's right. But.

00:42:56.240 --> 00:42:59.574
I mean debug performance is
probably better if you use like

00:42:59.574 --> 00:43:01.130
for instance in both places.

00:43:08.180 --> 00:43:10.410
Because if it's speculating.

00:43:11.040 --> 00:43:13.357
I mean, you know, who knows? The
compiler might reorder this

00:43:13.357 --> 00:43:15.180
stuff, but if it's speculating
through this if.

00:43:16.260 --> 00:43:18.030
Uh, then it doesn't need to wait
for.

00:43:18.900 --> 00:43:22.250
Both of them, like if we do it
this way then it needs to wait

00:43:22.250 --> 00:43:24.520
for both of these instructions
to finish.

00:43:25.780 --> 00:43:29.220
Uh, before I can do this before
I can do this line.

00:43:33.700 --> 00:43:34.170
Umm.

00:43:43.610 --> 00:43:45.940
I would be very surprised if
that turned up in profiling.

00:43:47.140 --> 00:43:49.030
We're talking about, like
subnanosecond here.

00:43:48.910 --> 00:43:49.320
Yeah.

00:43:50.040 --> 00:43:50.730
This is true.

00:43:52.190 --> 00:43:52.630
Uh.

00:44:03.500 --> 00:44:07.210
But I I bet that's why I was
written now.

00:44:10.200 --> 00:44:13.210
OK, so this is if we have any.

00:44:13.890 --> 00:44:15.320
Any offset at all.

00:44:16.040 --> 00:44:19.304
OK, we can we compute this
source and dest the source and

00:44:19.304 --> 00:44:20.260
destination mask.

00:44:21.440 --> 00:44:24.680
Uh, and we write B dest.

00:44:26.770 --> 00:44:29.800
Yeah. And we write and they're
they're inverses of each other.

00:44:31.150 --> 00:44:31.860
UM.

00:44:32.870 --> 00:44:33.740
Actually.

00:44:36.350 --> 00:44:38.780
OK. Yeah, they're strict
inverses of each other, but

00:44:38.780 --> 00:44:40.980
we're going to compute them
separately because.

00:44:41.740 --> 00:44:44.300
It's not clear that way and it's
better.

00:44:45.030 --> 00:44:45.600
Ah.

00:44:47.990 --> 00:44:48.760
UM.

00:44:51.720 --> 00:44:55.419
And then we out what are these V
1st and VCBE? OK, yeah. These

00:44:55.419 --> 00:44:56.710
are reinterpret casts.

00:44:58.160 --> 00:45:00.590
Is a pointer cast through.

00:45:03.070 --> 00:45:04.430
Char star.

00:45:07.310 --> 00:45:11.350
Uh or two char star, which is
fine because it's char star.

00:45:13.700 --> 00:45:14.560
Uh, I'm.

00:45:15.400 --> 00:45:17.640
So that doesn't cause.

00:45:18.620 --> 00:45:23.900
Fun aliasing problems, not that
it would actually, anyway.

00:45:25.780 --> 00:45:26.340
Umm.

00:45:29.110 --> 00:45:29.430
But.

00:45:30.200 --> 00:45:31.750
Yeah, copy bits into, OK.

00:45:32.900 --> 00:45:37.986
And the next to our alignment is
always the very next character

00:45:37.986 --> 00:45:38.940
and then we.

00:45:48.680 --> 00:45:50.750
VCBE last character.

00:46:01.970 --> 00:46:07.404
I am concerned that we might be
copying additional bits here

00:46:07.404 --> 00:46:09.720
that were uncopyable here.

00:46:14.270 --> 00:46:15.050
Or yeah.

00:46:17.650 --> 00:46:20.285
Oh no, but that would come up.
That would easily come up

00:46:20.285 --> 00:46:22.782
because we would have just
overwritten them. So yeah,

00:46:22.782 --> 00:46:24.400
that's fine. That would be
caught.

00:46:24.210 --> 00:46:24.720
Umm is.

00:46:25.530 --> 00:46:28.982
Is the strategy here right? A
partial byte? Do a block copy of

00:46:28.982 --> 00:46:32.379
bytes in the middle and then
write a partial byte at the end,

00:46:32.379 --> 00:46:34.900
in which case there should be no
overlapping.

00:46:33.580 --> 00:46:33.950
Yeah.

00:46:37.140 --> 00:46:37.540
Yeah.

00:46:38.510 --> 00:46:38.950
OK.

00:46:38.580 --> 00:46:40.780
I believe that is the strategy.

00:46:42.710 --> 00:46:45.870
Umm yeah V desks Ch.

00:46:48.480 --> 00:46:52.252
And yeah, copy unchecked returns
one after. I think the last

00:46:52.252 --> 00:46:53.180
thing it wrote.

00:47:00.000 --> 00:47:01.330
Yeah, and this is the same.

00:47:02.300 --> 00:47:02.920
Is above.

00:47:04.260 --> 00:47:05.600
And then we return.

00:47:08.980 --> 00:47:12.290
The desk and that we computed
way up here.

00:47:15.960 --> 00:47:16.750
UM.

00:47:20.190 --> 00:47:25.180
OK. So is right shift where we
actually compute that?

00:47:27.900 --> 00:47:28.540
Ohh OK.

00:47:50.140 --> 00:47:51.590
So this is if.

00:47:52.940 --> 00:47:55.700
I don't love the name of this is
Rachel. Very well, but.

00:47:56.550 --> 00:47:57.230
Umm.

00:47:58.480 --> 00:48:02.350
If the destination offset is
less than the source offset.

00:48:15.370 --> 00:48:16.500
Do we need a carry?

00:48:20.730 --> 00:48:22.640
Instead of just reversing the
order.

00:48:26.310 --> 00:48:26.870
I think it's.

00:48:28.430 --> 00:48:32.235
So this this is not, it's not
when the source and destination

00:48:32.235 --> 00:48:35.611
are overlapping, but it's when
they occur at different

00:48:35.611 --> 00:48:37.820
boundaries within the 32 bit
words.

00:48:38.960 --> 00:48:42.555
When things are exactly lying,
things are awesome because you

00:48:42.555 --> 00:48:45.918
can just directly copy the
unsigned ints over. But if you

00:48:44.770 --> 00:48:45.140
No.

00:48:45.918 --> 00:48:46.730
start at, say.

00:48:47.270 --> 00:48:47.910
Umm.

00:48:49.420 --> 00:48:50.350
You know why?

00:48:51.000 --> 00:48:52.730
You should only need to do.

00:48:54.050 --> 00:48:57.341
We should be able be able to get
aligned at some point, right,

00:48:57.341 --> 00:48:59.430
and only have to do a partial
bit copy.

00:49:01.030 --> 00:49:03.260
Yeah. So if we if we figure out.

00:49:04.660 --> 00:49:08.654
The so this is for if the offset
you're copying into is less than

00:49:08.654 --> 00:49:10.530
the offset you're copying from.

00:49:13.010 --> 00:49:14.470
And if that's the case?

00:49:17.020 --> 00:49:21.110
Ohh it's because.

00:49:20.330 --> 00:49:21.180
Yeah, in, in, in.

00:49:22.560 --> 00:49:26.300
Is because in this case you can
shift off the off the beginning.

00:49:28.060 --> 00:49:29.680
And if you shift off the
beginning like.

00:49:30.330 --> 00:49:33.748
So here you're going. OK how
many? You're gonna figure out

00:49:33.748 --> 00:49:37.513
how many characters are copying?
You're gonna pull out that many

00:49:37.513 --> 00:49:38.440
bits from first.

00:49:39.250 --> 00:49:41.532
And end up with, you know, a
bunch of zeros and then those

00:49:41.532 --> 00:49:43.853
bits and then maybe a bunch of
zeros, and then you're gonna

00:49:43.853 --> 00:49:44.240
shift off.

00:49:45.710 --> 00:49:48.470
Uh to align things.

00:49:52.900 --> 00:49:54.390
Ah.

00:49:56.380 --> 00:49:59.093
No, but that's your name. Even
that should not shift off the

00:49:59.093 --> 00:49:59.360
front.

00:50:00.820 --> 00:50:04.387
Well so. So basically there is
actually no, none, no, uh, no

00:50:04.387 --> 00:50:08.130
one herent relationship between
the urns and the source and the

00:50:08.130 --> 00:50:11.755
urns in the destination. Some of
the urns and the source will

00:50:11.755 --> 00:50:15.439
need to be mixed across two of
the urns in the destination. So

00:50:15.439 --> 00:50:19.006
that's the carry that miscoe
referring to. Essentially, when

00:50:19.006 --> 00:50:20.000
we're doing this.

00:50:21.280 --> 00:50:25.190
Transfer from the source to the
destination. We don't need to do

00:50:25.190 --> 00:50:28.800
individual bit operations, but
we do need. We do need to do

00:50:28.800 --> 00:50:32.770
some bitwise shifting and gluing
together of blocks to handle the

00:50:32.770 --> 00:50:36.560
fact that not everything will
occur on Nice 32 bit boundaries.

00:50:39.250 --> 00:50:39.850
Yeah.

00:50:43.820 --> 00:50:46.872
But I still don't see how. How
like if you're copying

00:50:46.872 --> 00:50:48.680
backwards, is what this case is.

00:50:49.940 --> 00:50:53.827
I don't see how you can shift
off the front when you do that,

00:50:53.827 --> 00:50:56.210
it's. You would need additional
bits.

00:50:58.490 --> 00:51:03.223
Year ohh. Except then to handle
that you you reverse the order

00:51:03.223 --> 00:51:04.800
in which you yeah OK.

00:51:06.840 --> 00:51:10.224
But there is no copy backwards
here. This is copy forwards.

00:51:06.850 --> 00:51:08.290
Said he always have the bits.

00:51:10.224 --> 00:51:12.480
We're always incrementing the VB
first.

00:51:22.720 --> 00:51:24.550
Yeah, so it's a but.

00:51:25.260 --> 00:51:29.595
It's like a carry, as if you
were copying backwards, but you

00:51:29.595 --> 00:51:32.650
do it by delaying by
incrementing VB desk.

00:51:33.360 --> 00:51:34.410
Only sometimes.

00:51:35.930 --> 00:51:38.270
Like V desk increments only
sometimes.

00:51:38.970 --> 00:51:40.080
When you are.

00:51:42.180 --> 00:51:43.640
Vtest may increment.

00:51:45.510 --> 00:51:47.710
Multiple times before you
incrementally be first.

00:51:49.690 --> 00:51:55.366
I do not believe that is the
case. On 3830, we get exactly 1

00:51:55.366 --> 00:52:00.763
increment of VCBE DAST per
increment of VB first on 3826,

00:52:00.763 --> 00:52:05.695
but we get an interesting
pattern here that does not

00:52:05.695 --> 00:52:11.371
usually occur in such copy loops
on 3828 and on 3832 we have

00:52:11.371 --> 00:52:16.861
multiple writes. So for every
loop on 3826 for the for the

00:52:16.861 --> 00:52:19.280
main for loop where we're.

00:52:17.480 --> 00:52:17.830
Yeah.

00:52:19.700 --> 00:52:23.862
Gonna process a drev first. We
actually split that across 2

00:52:23.862 --> 00:52:28.163
words of VB Dest, the 1st right,
then we advanced forward the

00:52:28.163 --> 00:52:32.324
pointer and then the second
write, and then each individual

00:52:32.324 --> 00:52:36.764
location in VB desk is written
to twice, once by the first half

00:52:36.764 --> 00:52:41.342
the loop and once by the 2nd. So
that's where the blocks are sort

00:52:41.342 --> 00:52:45.504
of getting fused together. But
there is aside from that odd

00:52:45.504 --> 00:52:48.070
pattern, there's no irregularity
in.

00:52:48.770 --> 00:52:53.237
How we're processing each
element is just instead of 1234

00:52:49.960 --> 00:52:52.310
And you're right. I I think I'm,
I think I'm.

00:52:53.237 --> 00:52:54.700
it's like 11223344.

00:52:55.140 --> 00:52:58.181
I think I'm thinking of things
kind of backwards to how they

00:52:58.181 --> 00:52:58.380
are.

00:53:01.050 --> 00:53:04.762
In terms of like when you
encounter like the bits that you

00:53:04.762 --> 00:53:06.020
need for that carry.

00:53:08.060 --> 00:53:09.550
Umm, alright.

00:53:11.390 --> 00:53:12.930
So source shift.

00:53:14.550 --> 00:53:15.920
Is just the distance.

00:53:20.600 --> 00:53:24.113
It is it is work, though I'm
not. I'm not sure if you're

00:53:24.113 --> 00:53:27.810
aware, but just so the our
viewers are aware my off is not.

00:53:28.450 --> 00:53:32.528
Umm if if I remember correctly
my office not an index within

00:53:32.528 --> 00:53:36.605
the entire vector, it's a bit
index within the word. Is that

00:53:36.605 --> 00:53:37.140
correct?

00:53:37.540 --> 00:53:38.020
Yeah.

00:53:38.180 --> 00:53:41.493
I think that's correct for the
vector bowl iterator, so my

00:53:40.370 --> 00:53:41.610
Yeah, that's why.

00:53:41.493 --> 00:53:43.290
office never. It's like 0 to 31.

00:53:43.860 --> 00:53:46.270
If it isn't there a lot of the
stuff we've looked at is wrong.

00:53:44.130 --> 00:53:45.760
Yeah, that's why this works.

00:53:47.170 --> 00:53:47.900
Yeah.

00:53:49.550 --> 00:53:51.220
That's why this works like.

00:53:53.070 --> 00:53:53.620
Umm.

00:53:56.490 --> 00:53:57.780
Like this covers both.

00:53:56.830 --> 00:54:00.076
That's also why that assertion
about last stop my off being

00:54:00.076 --> 00:54:02.780
zero and the a single block
source case was true.

00:54:04.370 --> 00:54:05.000
Yeah, that's right.

00:54:04.710 --> 00:54:07.750
Yeah, like, like, that's why
this cover is both like.

00:54:08.530 --> 00:54:12.240
Copying from different size
vectors and the same you know.

00:54:13.240 --> 00:54:15.110
The same sized ones at the same
position.

00:54:16.760 --> 00:54:17.090
OK.

00:54:18.300 --> 00:54:19.100
Umm.

00:54:20.660 --> 00:54:22.470
So we write the first source
Val.

00:54:23.960 --> 00:54:24.940
To the vector.

00:54:26.920 --> 00:54:27.690
Uh.

00:54:31.720 --> 00:54:34.300
Increment first our carry Val.

00:54:37.370 --> 00:54:38.220
Is.

00:54:40.130 --> 00:54:41.030
The next part.

00:54:41.900 --> 00:54:43.370
That we need in dest.

00:54:46.500 --> 00:54:48.990
And then we combine that and
write it to dest.

00:54:50.890 --> 00:54:51.730
And then.

00:54:53.580 --> 00:54:56.690
Ready for the next destination?
And we do this part again.

00:55:09.200 --> 00:55:10.430
So I shift.

00:55:18.970 --> 00:55:21.903
I guess because we're no longer
at the beginning, we don't need

00:55:21.903 --> 00:55:22.040
to.

00:55:23.380 --> 00:55:25.460
Yeah, we don't need to do this
masking anymore.

00:55:27.910 --> 00:55:30.020
As we pull out a whole word
here.

00:55:35.260 --> 00:55:37.760
And then pull out the other half
up here.

00:55:41.100 --> 00:55:41.980
That's clever.

00:55:51.110 --> 00:55:51.790
Umm.

00:55:53.270 --> 00:55:55.210
View first what's VCBE last.

00:55:59.310 --> 00:55:59.960
Uh.

00:56:09.130 --> 00:56:11.470
Again, if we're overlapping.

00:56:27.900 --> 00:56:29.940
Yes. So we didn't get a carry.

00:56:44.750 --> 00:56:48.530
And in the destination we have
to do the same.

00:56:50.560 --> 00:56:51.830
As before.

00:56:55.280 --> 00:56:56.630
Same as.

00:56:59.540 --> 00:57:00.170
Up here.

00:57:02.590 --> 00:57:05.950
And in addition, we then have to
do the tail end.

00:57:08.830 --> 00:57:10.780
Which doesn't need a carry.

00:57:20.910 --> 00:57:21.740
Rise.

00:57:26.060 --> 00:57:27.370
You just need to finish up.

00:57:40.980 --> 00:57:42.770
OK, wait, what's this else
branch on?

00:57:45.780 --> 00:57:47.770
OK, if if we're not a right
shift.

00:57:56.520 --> 00:57:57.910
It should be basically the same.

00:58:13.200 --> 00:58:16.120
Except we're keeping the use of
carry, Val and.

00:58:17.760 --> 00:58:20.430
Of the carry in the non carry
parts consistent.

00:58:22.050 --> 00:58:23.070
Which is why.

00:58:29.780 --> 00:58:31.310
Some pictures would be good
here.

00:58:32.600 --> 00:58:33.330
In the comments.

00:58:35.510 --> 00:58:36.990
Which is why we shift.

00:58:39.250 --> 00:58:39.910
And then.

00:58:42.300 --> 00:58:44.610
Front all he needs to write
carry.

00:58:57.880 --> 00:59:01.754
Is this cast of void needed?
That's a weird place to middle

00:59:01.754 --> 00:59:02.270
warning.

00:59:04.270 --> 00:59:07.199
I think Misco might have put it
there because it's needed in

00:59:07.199 --> 00:59:10.175
generic code, but I think in
this case we're guaranteed to be

00:59:10.175 --> 00:59:13.296
working with raw pointers to VL
base. I think that's the type of

00:59:13.296 --> 00:59:14.160
VB 1st and vctest.

00:59:14.890 --> 00:59:17.030
So you're right that the void
cache should be emitted.

00:59:15.180 --> 00:59:15.560
Yeah.

00:59:18.850 --> 00:59:19.720
Yeah, I guess.

00:59:21.640 --> 00:59:24.750
Yeah, I would have expected it
to be on DB first anyway.

00:59:25.990 --> 00:59:29.847
Oh oh, that that's a stylistic
preference that we have. So it

00:59:29.510 --> 00:59:33.095
Ohh avoid cast anywhere in
there. Avoid cast anywhere in

00:59:29.847 --> 00:59:31.340
is correct that you can.

00:59:33.095 --> 00:59:35.800
there. Silences the warning for
everybody.

00:59:37.110 --> 00:59:40.815
It the the answer is yes. But
no, it depends on how many

00:59:40.815 --> 00:59:44.845
operations you have. If you have
like plus plus X + + y + + Z

00:59:44.845 --> 00:59:48.940
then you can put it on the 1st
and the 2nd but not on the 3rd.

00:59:48.940 --> 00:59:52.580
That's too late. We can
eventually put it in the second

00:59:52.580 --> 00:59:56.610
or in the middle because that
handles the most cases and it's

00:59:56.610 --> 01:00:00.705
the most visually unambiguous.
If you said cast void Increment

01:00:00.705 --> 01:00:04.995
VB first comma, increment V Dest
that does syntactically work. It

01:00:04.995 --> 01:00:08.440
makes the left hand side of the
comma operator void.

01:00:08.680 --> 01:00:11.769
But it looks weird because we
don't usually think of the void

01:00:11.769 --> 01:00:14.858
cast as binding tightly, even
though in this case it does. If

01:00:14.858 --> 01:00:18.046
you put in the middle, it works
because it makes the right hand

01:00:18.046 --> 01:00:21.335
side of the comma operator void,
but it visually is unmistakable.

01:00:21.335 --> 01:00:24.274
It's clear that we're casting
the right hand side to avoid

01:00:24.274 --> 01:00:25.370
before doing anything.

01:00:25.850 --> 01:00:26.410
Umm.

01:00:27.210 --> 01:00:30.494
And the nice thing is if you put
it on the second one then that

01:00:30.494 --> 01:00:32.700
also works when there's three
occurrences.

01:00:33.180 --> 01:00:36.756
Umm it's it void defies the
right hand side of the first

01:00:36.756 --> 01:00:40.394
comma operator and the left hand
side of the second comma

01:00:40.394 --> 01:00:43.970
operator and I don't think we
ever have four in the STL.

01:00:55.900 --> 01:00:57.030
OK so.

01:00:58.190 --> 01:01:00.732
What cases are we going to have
to test? We're gonna have to

01:01:00.732 --> 01:01:00.940
test.

01:01:01.680 --> 01:01:02.610
Aligned.

01:01:03.510 --> 01:01:04.500
One character.

01:01:05.530 --> 01:01:08.140
On each character, we're going
to have to test single.

01:01:10.390 --> 01:01:11.980
A single block source.

01:01:13.260 --> 01:01:16.890
Uh, where the personal ascertain
the same block. Then we're gonna

01:01:16.890 --> 01:01:19.640
have to test unaligned both
forward and backward.

01:01:21.210 --> 01:01:23.420
Online by Char both forward and
backward.

01:01:25.960 --> 01:01:26.320
No.

01:01:28.100 --> 01:01:29.130
I don't like this.

01:01:34.870 --> 01:01:35.190
Umm.

01:01:40.950 --> 01:01:43.793
Oh, it's sort of random. OK,
that's better than if it was

01:01:43.793 --> 01:01:45.950
just true, false, true, false,
true, false.

01:01:47.790 --> 01:01:48.270
Uh.

01:01:52.210 --> 01:01:53.060
I'll allow it.

01:01:54.090 --> 01:01:54.720
For now.

01:01:58.510 --> 01:01:59.710
Oh, and it's pretty existing.

01:02:15.840 --> 01:02:17.200
Yeah, that's just moving that.

01:02:19.380 --> 01:02:20.510
Moving this array.

01:02:22.570 --> 01:02:23.070
Here.

01:02:24.760 --> 01:02:27.160
We could probably constexpr, but
it doesn't really matter.

01:02:29.240 --> 01:02:30.210
And only.

01:02:29.770 --> 01:02:33.676
You can't have a top level
constexpr vector because the

01:02:33.676 --> 01:02:35.420
allocation would survive.

01:02:38.870 --> 01:02:39.980
Well, it could be an array.

01:02:41.960 --> 01:02:43.880
But then it's not adaptable.

01:02:42.980 --> 01:02:46.231
Yeah, it could be, yeah. Then we
would need to make a vector bowl

01:02:46.231 --> 01:02:47.660
whenever we wanted to use it.

01:02:49.310 --> 01:02:53.090
OK, test copy, no offset switch
length. Where do we?

01:03:14.190 --> 01:03:15.130
This could be.

01:03:21.300 --> 01:03:23.370
Why can't we just take a range
of the?

01:03:25.580 --> 01:03:28.750
Ohh, because that would do a
copy. I see. Yeah, great.

01:03:29.790 --> 01:03:30.570
And makes sense.

01:03:34.510 --> 01:03:35.210
Uh.

01:03:38.160 --> 01:03:39.710
We can't just copying.

01:03:54.610 --> 01:03:56.930
His next really necessary here
I.

01:03:59.550 --> 01:04:00.420
Yeah, it's fine.

01:04:02.030 --> 01:04:04.990
It's not a big deal, it's just a
weird style.

01:04:07.790 --> 01:04:09.250
OK, so this should be.

01:04:10.950 --> 01:04:12.200
Totally aligned.

01:04:14.260 --> 01:04:15.580
And we have.

01:04:17.120 --> 01:04:19.130
That for that and.

01:04:20.560 --> 01:04:22.870
Yeah, except we have caps on the
end.

01:04:24.500 --> 01:04:26.960
And this should this should be a
single block.

01:04:28.220 --> 01:04:29.840
There should be a full single
block.

01:04:33.550 --> 01:04:34.080
Good.

01:04:55.720 --> 01:04:57.490
OK, but this doesn't test.

01:05:00.880 --> 01:05:03.360
On the tail, really.

01:05:04.750 --> 01:05:07.780
You're copying into a tail, but
there's nothing there so.

01:05:09.070 --> 01:05:10.740
Need to make sure that that
happens.

01:05:40.530 --> 01:05:41.710
Happy Ann.

01:05:51.020 --> 01:05:52.670
OK, this is identical though.

01:05:54.830 --> 01:05:58.040
We're not really testing copy
and being.

01:06:01.790 --> 01:06:05.170
Yeah, because it's copying into
the full length of the vector.

01:06:06.220 --> 01:06:07.390
The destination vector.

01:06:18.580 --> 01:06:19.910
Copy backward.

01:06:37.220 --> 01:06:37.500
What?

01:06:48.490 --> 01:06:50.020
Ohh, he goes right. Yeah.

01:07:07.200 --> 01:07:11.804
Although presumably the point of
copy backward is to change the

01:07:11.804 --> 01:07:13.530
rules about overlapping.

01:07:16.820 --> 01:07:17.380
That's correct.

01:07:19.310 --> 01:07:20.990
Yeah, OK. So we need to test
that.

01:07:35.440 --> 01:07:39.310
And of course with copy forward
too, so offset in the source.

01:07:45.580 --> 01:07:49.399
And then this. That weird. Yeah.
OK. So that's just because one

01:07:49.399 --> 01:07:51.010
of these values is omitted.

01:07:54.010 --> 01:07:56.920
Wait. False, true false for 67.

01:08:00.480 --> 01:08:02.790
Should we not omit one and then?

01:08:04.980 --> 01:08:05.990
Have the offset.

01:08:13.870 --> 01:08:18.023
So I I I haven't thought about
in detail exactly what these

01:08:18.023 --> 01:08:19.130
tests are doing.

01:08:20.390 --> 01:08:24.344
But I am a little bit nervous
that we read through so many

01:08:24.344 --> 01:08:28.030
special cases in the product
code and there's a lot of

01:08:28.030 --> 01:08:32.252
special cases and there have to
be and it looks like they were

01:08:32.252 --> 01:08:36.474
all diligently taken care of.
But when I see that many special

01:08:36.474 --> 01:08:40.562
cases, then I sort of want to
see really exhaustive testing.

01:08:40.562 --> 01:08:43.913
And So what I would have
expected to see here was

01:08:40.880 --> 01:08:41.190
Yeah.

01:08:43.913 --> 01:08:45.320
something that tests.

01:08:46.800 --> 01:08:51.737
For every possible alignment
within a 32 bit value of the

01:08:51.737 --> 01:08:56.588
source and for every possible
alignment within 32 of the

01:08:56.588 --> 01:09:02.120
destination vector bool and for
a good mix of lengths to handle.

01:09:03.560 --> 01:09:07.299
The special cases of single
block like exactly 2 blocks or a

01:09:07.299 --> 01:09:08.280
bunch of blocks.

01:09:08.700 --> 01:09:12.214
Umm test all that now the
problem is you do end up with

01:09:09.920 --> 01:09:10.380
Yeah, well.

01:09:12.214 --> 01:09:16.104
the multiplicative explosion,
but it's actually not that bad.

01:09:16.104 --> 01:09:19.492
Like if you have 32 offsets
times 32 offsets times 32

01:09:19.492 --> 01:09:23.444
possible links, that's only 32
Ki, just multiplied it out test

01:09:23.444 --> 01:09:27.146
cases. And if we believe that
this should be fast now then

01:09:25.040 --> 01:09:27.660
Yeah, I would prefer so I think.

01:09:27.146 --> 01:09:28.150
could be doable.

01:09:28.450 --> 01:09:32.791
I think the test is trying to
like. It's very in this way

01:09:32.791 --> 01:09:37.506
because it wants to test vector
bool without like using vector

01:09:37.506 --> 01:09:37.880
bool.

01:09:38.580 --> 01:09:41.856
But I think it might be better
for the test to like implement

01:09:41.856 --> 01:09:43.970
its own, like really brain dead
vector.

01:09:44.730 --> 01:09:47.711
Well, the the we have such a
thing, it's called it's called

01:09:45.270 --> 01:09:46.250
With iterators.

01:09:47.711 --> 01:09:50.890
vector unsigned care. Like you
can take all the values that you

01:09:50.890 --> 01:09:53.871
would put into a vector bool
instead put them into a vector

01:09:53.871 --> 01:09:57.149
unsigned care and now you have a
reliable source of truth. You do

01:09:57.149 --> 01:10:00.229
need to do comparisons you know
element wise, but that's what

01:10:00.229 --> 01:10:01.620
stood equal will do anyways.

01:10:05.010 --> 01:10:07.987
Yeah, the the reason I I could
understand like code not wanting

01:10:07.987 --> 01:10:10.546
to do the full exhaustive
multiplication, but it seems

01:10:10.546 --> 01:10:13.430
like there would be better ways
to do that like testing only.

01:10:11.850 --> 01:10:13.240
Also we last code.

01:10:14.080 --> 01:10:16.605
Yeah, yeah, yeah. Basically what
that's doing, where it only

01:10:16.605 --> 01:10:17.930
tests like certain lengths, but.

01:10:18.560 --> 01:10:22.681
Yeah, this is not really
especially because I don't see

01:10:19.160 --> 01:10:20.000
I'm worried it's.

01:10:22.681 --> 01:10:24.300
any overlapping tests.

01:10:25.050 --> 01:10:29.614
Yeah, no overlapping. And I what
I'm not seeing is exhaustive

01:10:29.614 --> 01:10:34.178
testing of the possible offsets.
It looks like there might be

01:10:34.178 --> 01:10:36.460
some there. I just I'm worried.

01:10:36.560 --> 01:10:40.316
Uh, we we've been burned a few
times by algorithmic changes

01:10:37.560 --> 01:10:38.500
Yeah, I I.

01:10:40.316 --> 01:10:44.384
where we tested some stuff, but
we weren't really diligent about

01:10:44.384 --> 01:10:48.140
it and we forgot. Oh, wait, what
if this source is like 33?

01:10:46.290 --> 01:10:50.240
That's what I'm gonna say a
given like.

01:10:51.690 --> 01:10:54.601
We can just talk test this
exhaustively. It's not a big

01:10:54.601 --> 01:10:55.900
deal, right? Like we can.

01:10:57.520 --> 01:10:58.570
Like we can do it.

01:11:17.030 --> 01:11:17.970
Our strengths.

01:11:20.550 --> 01:11:21.090
Huh.

01:12:33.030 --> 01:12:36.184
Uh, for when you say overlapping
ranges, could you clarify that

01:12:36.184 --> 01:12:39.239
you only want to test the ones
that are actually supported by

01:12:39.239 --> 01:12:39.880
the standard?

01:12:40.290 --> 01:12:40.800
Yes.

01:12:42.190 --> 01:12:42.820
OK.

01:12:44.080 --> 01:12:44.610
Ah.

01:12:50.850 --> 01:12:54.670
That is to say, the.

01:12:57.090 --> 01:12:58.620
Destinations before the source.

01:13:00.200 --> 01:13:00.590
Or.

01:13:02.700 --> 01:13:03.280
You're muted.

01:13:06.640 --> 01:13:07.470
You're still muted.

01:13:10.310 --> 01:13:13.255
Ah, sorry, I would say, uh, only
the ones that are permitted by

01:13:13.255 --> 01:13:16.153
the standard, because the answer
is different for copy forward

01:13:16.153 --> 01:13:18.960
versus copy backwards. So you
don't want to be too specific.

01:13:22.050 --> 01:13:24.240
Sorry, I'm still figuring out
this mute button apparently.

01:13:27.570 --> 01:13:27.940
Yeah.

01:13:34.080 --> 01:13:35.880
Yeah. And then as a bonus.

01:13:37.870 --> 01:13:38.610
I mean, you know.

01:13:39.760 --> 01:13:42.430
Like if if we're using a, yeah.

01:13:58.340 --> 01:14:01.966
Should you clarify what you mean
by using vector unsigned care

01:14:01.966 --> 01:14:03.290
for this? I worry that.

01:14:04.670 --> 01:14:07.010
What we're talking about might
not be captured here.

01:14:07.850 --> 01:14:11.720
I think you mean like it's as
the reference, right?

01:14:10.760 --> 01:14:10.910
Yeah.

01:14:12.690 --> 01:14:14.120
Using vector as.

01:14:19.090 --> 01:14:19.700
Hey.

01:14:19.510 --> 01:14:20.170
Yeah, I.

01:14:22.690 --> 01:14:24.000
Yeah, that's a good way to put
it.

01:14:28.190 --> 01:14:29.540
I don't know if we need.

01:14:30.340 --> 01:14:33.092
I think I'm less concerned about
random generation because that I

01:14:33.092 --> 01:14:35.636
mean we we could always ask for
that, but that requires more

01:14:35.636 --> 01:14:38.263
infrastructure and we we have
that elsewhere in the code base,

01:14:38.263 --> 01:14:38.430
but.

01:14:39.870 --> 01:14:44.064
In this case, we're not actually
that concerned about the data

01:14:44.064 --> 01:14:48.192
dependency like as long as the
pattern of trues and falses is

01:14:45.270 --> 01:14:45.570
Yeah.

01:14:48.192 --> 01:14:49.590
kind of jumbled then.

01:14:50.260 --> 01:14:52.550
And it as long as it's not so
repetitive.

01:14:50.920 --> 01:14:53.639
I think it's the obvious way to
do it. It's the natural way to

01:14:53.639 --> 01:14:54.200
do it anyway.

01:14:56.530 --> 01:14:57.020
Yeah.

01:14:59.360 --> 01:15:03.046
Because we really care about is
variation in the offsets and the

01:15:03.046 --> 01:15:06.392
lengths and as long as the
pattern doesn't exactly overlap

01:15:06.392 --> 01:15:07.810
them, we're fine with it.

01:15:08.100 --> 01:15:11.240
Yeah. I mean, yeah, there's only
goes up to 67.

01:15:12.680 --> 01:15:13.240
Let's just.

01:15:15.690 --> 01:15:19.268
That's not too bad. It's like 2
words. It's not huge. It's like

01:15:19.268 --> 01:15:22.230
2 words in a little bit. It does
seem kind of small.

01:15:21.080 --> 01:15:21.850
But then you don't.

01:15:22.510 --> 01:15:24.960
Yeah, but then you don't get 3
bytes.

01:15:25.760 --> 01:15:26.190
Yeah.

01:15:27.690 --> 01:15:30.369
We could be missing something
there. There is at least a

01:15:27.840 --> 01:15:28.530
Uh.

01:15:30.369 --> 01:15:33.000
little bit of attention around
3132, but what about 33?

01:15:34.260 --> 01:15:37.851
What about all the offsets? I'm
just not seeing that I wanted to

01:15:37.851 --> 01:15:41.220
see like 3 nested loops and
maybe some hackery to deal with.

01:15:42.340 --> 01:15:43.510
It's taking too long.

01:15:45.470 --> 01:15:46.900
But that would make me feel a
lot better.

01:15:59.280 --> 01:16:02.576
And of course, the context here
that Charlie and I are well

01:16:02.576 --> 01:16:05.651
aware of, but have not
explicitly stated as we just got

01:16:05.651 --> 01:16:08.837
done dealing with fixing a bunch
of regressions caused by

01:16:08.837 --> 01:16:12.243
performance optimizations and
those performance optimizations

01:16:12.243 --> 01:16:15.593
were very good. I'm glad we took
them, but we got to be real

01:16:15.593 --> 01:16:17.790
careful about breaking code that
works.

01:16:18.340 --> 01:16:22.410
Umm at runtime because that's
always painful.

01:16:23.250 --> 01:16:26.375
It's a good cause. These are all
runtime optimizations. That's

01:16:26.375 --> 01:16:29.499
what's tricky with compile time
stuff. It's less risky because

01:16:29.499 --> 01:16:32.773
if it doesn't compile OK, we can
fix that. It doesn't really ship

01:16:32.773 --> 01:16:35.550
to users, but if it breaks it
runtime, it's always bad.

01:17:02.610 --> 01:17:06.465
Yeah. Well, so for size, I mean
we wouldn't exhaustively test

01:17:06.465 --> 01:17:08.330
with every size we would test.

01:17:09.640 --> 01:17:10.150
You know.

01:17:13.340 --> 01:17:14.000
We would take.

01:17:14.000 --> 01:17:18.407
I I would say up up to some
limit. I'm honestly like 100 is

01:17:18.407 --> 01:17:20.610
fine. Once we're once up to a.

01:17:18.450 --> 01:17:19.920
Well, well, no, it won't, but
it.

01:17:21.220 --> 01:17:25.257
But but it would have to be. You
know, we, we'd have to either go

01:17:25.257 --> 01:17:26.970
by multiples of eight or 32.

01:17:27.630 --> 01:17:31.492
Oh, no, no, that's that's scary.
Like you. Don't you specifically

01:17:27.990 --> 01:17:29.220
Because if we're testing.

01:17:31.492 --> 01:17:35.062
don't want multiples 8 cause
that that's gonna hide baldness

01:17:35.062 --> 01:17:35.940
that occurs at.

01:17:36.660 --> 01:17:39.050
You know non power of two
boundaries or something.

01:17:38.010 --> 01:17:38.430
No, but.

01:17:39.300 --> 01:17:40.640
The problem is that if we're.

01:17:39.880 --> 01:17:41.350
Are you concerned about the
time?

01:17:42.260 --> 01:17:46.300
Well, yeah, if we're testing
both if we're exhaustively

01:17:46.300 --> 01:17:49.690
testing both the size and the
shift positions.

01:17:50.970 --> 01:17:54.858
Yeah. Yeah. So, so there, there
we could we could like The thing

01:17:52.150 --> 01:17:53.670
That's three things, right?

01:17:54.858 --> 01:17:57.968
is once the test has been
written then it's easy to

01:17:57.968 --> 01:18:00.600
selectively skip or end early or
something.

01:18:01.020 --> 01:18:04.825
Umm, where we maybe go densely
like 12345. You know, up to

01:18:04.825 --> 01:18:08.437
maybe 10 and then we start
skipping stump. But we still

01:18:08.437 --> 01:18:12.371
make sure to test around, you
know the 3032 boundary and the

01:18:12.371 --> 01:18:16.499
64 boundary and then throw in an
odd prime here. There once you

01:18:16.499 --> 01:18:20.692
have the core loop written, it's
very easy to make faster. But I

01:18:20.692 --> 01:18:24.884
think the focus should be first
on let's just test everything up

01:18:24.884 --> 01:18:28.883
to the full you know 32 * 32 *
100. Just go nuts and then see

01:18:28.450 --> 01:18:29.250
Yeah, but I think.

01:18:28.883 --> 01:18:29.850
how fast it is.

01:18:29.930 --> 01:18:32.870
But I think everything is like 3
to the.

01:18:34.720 --> 01:18:36.850
200 something power.

01:18:37.720 --> 01:18:41.442
No. So, so, so we're we're all
the possible variations. I was

01:18:41.442 --> 01:18:45.164
just doing the math in my head,
there's what offset are we in

01:18:45.164 --> 01:18:48.645
for the source? There's 32
possible bits. What offset are

01:18:48.645 --> 01:18:52.187
we beginning at for the desk
again 32 and then how long is

01:18:52.187 --> 01:18:56.149
the sequence that we're copying?
How many bits? So that's 32 * 32

01:18:56.149 --> 01:18:58.370
times, say 100. That's not that
big.

01:18:58.430 --> 01:19:01.941
OK, I was thinking I was
thinking the length, the number

01:19:01.941 --> 01:19:05.760
of bits and then the beginning
iterator and the end iterator.

01:19:07.710 --> 01:19:08.570
Which is much worse.

01:19:07.990 --> 01:19:12.360
The length is the number of
bits, so so those are the same.

01:19:10.400 --> 01:19:13.242
Yeah, yeah, but the the
beginning and ended rather is

01:19:13.242 --> 01:19:14.610
different from the offset.

01:19:16.900 --> 01:19:17.700
Umm.

01:19:20.000 --> 01:19:23.580
Once you have the bit offset.

01:19:25.170 --> 01:19:28.337
Of an iterator doesn't really
matter where in the vector bool

01:19:28.337 --> 01:19:31.300
you are. You're right that it
is. It is a difference but.

01:19:32.330 --> 01:19:35.807
The algorithm does not care
about words in the vector bool

01:19:35.807 --> 01:19:39.579
that occur before the beginning
iterator. The vector could have

01:19:39.579 --> 01:19:43.175
a 1032 bit words before that
initial iterator. We just don't

01:19:39.620 --> 01:19:39.820
Yeah.

01:19:43.175 --> 01:19:44.530
care about any of them.

01:19:45.770 --> 01:19:50.183
So we really only care about the
offset where it is like the the

01:19:50.183 --> 01:19:54.529
universe sort of begins and ends
at the VB 1st and VB last word

01:19:54.529 --> 01:19:55.140
pointers.

01:19:55.220 --> 01:19:58.679
Umm, so that's why I think only
the offset matter offset in the

01:19:58.679 --> 01:19:59.490
length matters.

01:20:15.900 --> 01:20:19.540
And what about the number of of
of bytes between them?

01:20:21.210 --> 01:20:25.710
Umm, I think that's captured by
the number of bits being copied.

01:20:26.360 --> 01:20:28.573
Those are the only three
parameters I can see that really

01:20:28.573 --> 01:20:28.840
matter.

01:20:29.180 --> 01:20:32.305
OK, so we'll say instead of bits
in the vector, we'll say number

01:20:32.305 --> 01:20:32.690
of bits.

01:20:36.920 --> 01:20:37.880
Yeah, being copied.

01:20:38.990 --> 01:20:42.760
Yeah. OK, yeah, that's that's
fine. That's that's exhaust

01:20:42.760 --> 01:20:44.190
exhaustively testable.

01:20:45.110 --> 01:20:48.834
Yeah. And then if we find 32 *
32 * 100 is too slow, then we

01:20:48.834 --> 01:20:52.558
can optimize it or run only the
fast matrix or something. We

01:20:52.558 --> 01:20:56.404
we've dealt with this in like
the random generator tests where

01:20:56.404 --> 01:20:57.930
those are a little hefty.

01:20:58.410 --> 01:21:02.960
Umm or CARICOM, where we we did
end up randomizing it but.

01:21:01.260 --> 01:21:01.720
No, but.

01:21:02.890 --> 01:21:06.580
But 32 * 32 * 100 is is fine.
It's like.

01:21:06.700 --> 01:21:08.300
Yeah, zero. That's zero. That's
nothing.

01:21:08.910 --> 01:21:10.160
Yeah, it's, it's.

01:21:09.500 --> 01:21:11.380
It's not like testing all 32 bit
floats.

01:21:12.750 --> 01:21:13.300
Yeah.

01:21:14.740 --> 01:21:16.140
And even yeah, like is.

01:21:19.670 --> 01:21:22.440
It's fine now. It may be in
debug mode, yeah.

01:21:26.340 --> 01:21:28.970
Let's see. Well, let, let's take
a quick look at the test.

01:21:27.990 --> 01:21:28.690
And.

01:21:30.140 --> 01:21:33.198
Oh yeah. The best horse. Yeah,
I'm the the fun secret about our

01:21:30.420 --> 01:21:30.730
And the.

01:21:33.198 --> 01:21:35.970
test is that they're all
compiled and non optimized mode.

01:21:35.970 --> 01:21:38.455
I mean, we do vary between
release and debug and we

01:21:38.455 --> 01:21:40.940
actually do not turn on
optimizations for the tests

01:21:40.940 --> 01:21:42.230
except for the fast matrix.

01:21:45.210 --> 01:21:47.170
Which is fine because usually
our code doesn't care.

01:21:48.490 --> 01:21:49.800
Yeah, well, OK.

01:21:58.670 --> 01:22:00.500
Interesting distribution.

01:22:05.810 --> 01:22:09.853
Right. Yeah. So honestly, most
of the code to do all this stuff

01:22:09.853 --> 01:22:10.800
already exists.

01:22:11.930 --> 01:22:14.150
Like most of this exhaustive
testing code.

01:22:16.480 --> 01:22:19.750
He thought his right here, like
you just need to.

01:22:21.370 --> 01:22:24.250
Also do it the vector unsigned
int.

01:22:27.310 --> 01:22:28.480
And do the comparison.

01:22:34.940 --> 01:22:35.770
Umm.

01:22:41.860 --> 01:22:42.350
Yeah.

01:22:59.190 --> 01:23:00.930
And that's fine. I'm fine with
that.

01:23:05.490 --> 01:23:07.070
We could just use well.

01:23:07.950 --> 01:23:09.100
You know fine with that too.

01:23:13.120 --> 01:23:14.130
As preexisting.

01:23:19.560 --> 01:23:21.750
Let's make sure we're not
already doing what we want.

01:23:24.900 --> 01:23:25.390
No.

01:23:26.670 --> 01:23:29.444
Yeah, I think this is the first
time we really care about

01:23:29.444 --> 01:23:32.313
boundaries. The count stuff
cared a little bit, but there's

01:23:32.313 --> 01:23:33.700
just so many more cases here.

01:23:34.270 --> 01:23:35.010
UM.

01:23:37.550 --> 01:23:40.510
It's it's all the special casing
that all the if essentially the

01:23:40.510 --> 01:23:43.014
nested ifs that we really want
like 100% code coverage

01:23:43.014 --> 01:23:43.560
essentially.

01:23:44.040 --> 01:23:47.640
Yeah, just wait until somebody
vectorizes this even more.

01:23:51.880 --> 01:23:52.280
Well.

01:23:55.240 --> 01:23:58.854
I guess doing that you just it's
just that inner memmove loop

01:23:58.854 --> 01:24:01.010
which memmove will vectorize
anyway?

01:24:03.640 --> 01:24:07.836
Yeah. So I think that's kind of
my feedback. I I don't think the

01:24:07.836 --> 01:24:08.610
this is I I.

01:24:10.150 --> 01:24:13.080
It's not hard to to write these
these exhaustive tests.

01:24:15.280 --> 01:24:17.770
But the the actual
implementation looks.

01:24:21.560 --> 01:24:23.170
It's fiddly, but it's fine.

01:24:24.930 --> 01:24:26.220
And pictures would been nice.

01:24:33.150 --> 01:24:35.843
I don't think the code is
relatively clear. It is the sort

01:24:35.843 --> 01:24:38.628
of thing that benefits from
having a pad of scratch paper as

01:24:38.628 --> 01:24:39.860
you work through each line.

01:24:41.270 --> 01:24:43.802
I think with the test that we're
that would increase my

01:24:43.802 --> 01:24:46.786
confidence and ohh before we get
to the end of our time slot, the

01:24:46.786 --> 01:24:49.589
constness you said you're gonna
come back and comment on that

01:24:49.220 --> 01:24:50.510
Yeah, the concepts.

01:24:49.589 --> 01:24:49.860
later.

01:24:53.530 --> 01:24:56.610
Yeah, I I don't see us writing
through like.

01:24:57.740 --> 01:24:58.250
Yeah, well.

01:24:59.070 --> 01:24:59.820
Yeah, like.

01:25:04.840 --> 01:25:06.030
Well, we be dazed.

01:25:06.760 --> 01:25:07.070
We.

01:25:06.770 --> 01:25:09.778
Yeah, that desk of course needs
to be writable, but first and

01:25:09.778 --> 01:25:10.020
last.

01:25:30.240 --> 01:25:32.844
It might be worth mentioning in
this comment that this implies

01:25:32.844 --> 01:25:35.531
cascading changes like with the
character pointers. Those should

01:25:35.531 --> 01:25:36.110
also be Const.

01:25:39.320 --> 01:25:40.510
I'll I'll just put another
comment.

01:25:41.430 --> 01:25:41.690
OK.

01:25:56.660 --> 01:25:57.990
He, he, he.

01:26:01.950 --> 01:26:03.110
So yeah.

01:26:04.960 --> 01:26:07.538
I'm sure whoever ends up better
than this, we'll figure out

01:26:07.538 --> 01:26:10.373
without a comment here. When the
compiler rejects the reinterpret

01:26:10.373 --> 01:26:11.490
cast that's casting awake.

01:26:13.430 --> 01:26:15.420
Yeah, that that's a nice
advantage of the.

01:26:16.620 --> 01:26:19.344
Forbidding of sea cast in our
code base C cast are just say

01:26:19.344 --> 01:26:19.980
yeah whatever.

01:26:27.690 --> 01:26:32.490
And yeah, Const char star can
can can alias in the same way as

01:26:32.490 --> 01:26:33.480
Char star so.

01:26:37.550 --> 01:26:38.370
That's fine.

01:26:42.290 --> 01:26:45.108
Ohh would you need that boy cast
on the between the iterator

01:26:45.108 --> 01:26:46.170
increments, by the way.

01:26:46.700 --> 01:26:47.400
Oh, why?

01:26:48.290 --> 01:26:51.440
Container iterators are
parameterized on pointer types.

01:26:49.130 --> 01:26:49.480
Uh.

01:26:51.340 --> 01:26:52.610
Ohh allocator.

01:26:51.440 --> 01:26:54.645
Generally speaking on fancy
pointer types. In this case,

01:26:54.645 --> 01:26:58.245
it's the allocator specifically,
but it must at least be on the

01:26:55.200 --> 01:26:55.980
Ah.

01:26:57.380 --> 01:26:58.000
They're not.

01:26:58.245 --> 01:27:01.000
the pointer type of the
allocator which the user

01:27:01.000 --> 01:27:02.800
controls. So these are hackable.

01:27:02.290 --> 01:27:02.960
They're they're not.

01:27:03.800 --> 01:27:06.911
Are there no hold on art? Can
you scroll up? Is VCBE first and

01:27:06.911 --> 01:27:09.726
VB desk. Are those raw pointers?
I thought they were raw

01:27:09.726 --> 01:27:10.170
pointers.

01:27:11.080 --> 01:27:14.008
Oh, I'm sorry. Yes, these are
raw pointers. I'm not the vector

01:27:14.008 --> 01:27:15.960
blurring writers anymore. I'm
wrong, yes.

01:27:14.810 --> 01:27:15.290
Yeah.

01:27:16.180 --> 01:27:18.730
Yeah, yeah, Casey's wrong.
Amazing.

01:27:18.180 --> 01:27:19.510
I'm so happy to be wrong.

01:27:21.560 --> 01:27:21.980
Yeah.

01:27:22.570 --> 01:27:25.150
There's something that user
can't hijack in it's raw

01:27:25.150 --> 01:27:25.880
pointers, yeah.

01:27:25.930 --> 01:27:26.420
Yeah.

01:27:28.420 --> 01:27:31.458
Raw pointers to actually no raw
pointers. General Fine, even if

01:27:28.540 --> 01:27:29.210
Yes.

01:27:31.458 --> 01:27:32.930
they are to user defined types.

01:27:34.360 --> 01:27:34.710
Yes.

01:27:34.530 --> 01:27:35.340
Yeah.

01:27:40.990 --> 01:27:44.310
I yeah, that I don't think we
need that.

01:27:45.020 --> 01:27:45.470
Umm.

01:27:47.180 --> 01:27:50.674
And if the compiler is
complaining about throwing those

01:27:50.674 --> 01:27:54.418
values away, it's being bad and
you should feel bad because

01:27:54.418 --> 01:27:54.730
like.

01:27:55.030 --> 01:27:56.980
Oh, yeah, yeah, the compiler
would not complain about that.

01:27:55.770 --> 01:27:59.177
That's the one. That's the one
reasonable place to put a comma

01:27:59.177 --> 01:27:59.880
up, you know.

01:28:01.140 --> 01:28:01.450
Yeah.

01:28:04.760 --> 01:28:08.831
Yeah. OK. So other than the
testing changes, this looks

01:28:08.831 --> 01:28:13.555
pretty in the Const stuff. This
looks pretty good and let's see,

01:28:13.555 --> 01:28:16.390
we do, let's say we do call test
copy.

01:28:18.150 --> 01:28:20.140
And it calls. Let's see.

01:28:21.650 --> 01:28:22.540
Yeah, this is all.

01:28:23.530 --> 01:28:25.700
Probably doesn't need to be in
the video review.

01:28:28.350 --> 01:28:30.680
And it would be easier to do
with the editor split.

01:28:33.130 --> 01:28:33.460
But.

01:28:33.200 --> 01:28:35.330
Yeah, we're just at the end of
the time slot anyways.

01:28:35.180 --> 01:28:37.690
Yeah, we are at the end of the
time slot as well. So I'm not

01:28:37.690 --> 01:28:40.077
gonna go through and make sure
that every single test was

01:28:40.077 --> 01:28:40.530
called and.

01:28:41.610 --> 01:28:44.240
Stuff like that now. Plus I'm
known to forget that myself.

01:28:45.050 --> 01:28:45.450
Umm.

01:28:47.970 --> 01:28:50.150
Yeah, OK. Ohh I should.

01:28:51.380 --> 01:28:52.160
Submit their view.

01:28:54.420 --> 01:28:55.110
Before I forget.

01:28:57.290 --> 01:28:58.540
All right. Thanks everybody.

01:29:00.270 --> 01:29:01.010
Thank you, Charlie.

01:29:00.290 --> 01:29:00.770
Uh.

01:29:02.630 --> 01:29:03.570
Always fun.

01:29:06.120 --> 01:29:06.840
Uh.

01:29:08.220 --> 01:29:10.212
And yeah, it's some pretty
substantial performance

01:29:10.212 --> 01:29:10.720
improvements.

01:29:11.670 --> 01:29:12.950
You know, stop the recording.
